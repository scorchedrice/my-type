# ğŸ“Œ 3.1 Partial, Required, Readonly, Pick, Record

## Partial

ê¸°ì¡´ ê°ì²´ì˜ ì†ì„±ì„ ì „ë¶€ ì˜µì…”ë„ë¡œ ë§Œë“œëŠ” Partial

```ts
type MyPartial<T> = {
  [P in keyof T]?: T[P];
};

type Result = MyPartial<{ a: string, b: number }>;
/*
type Result = {
  a?: string | undefined;
  b?: number | undefined;
}
*/
```

## Required

ëª¨ë“  ì†ì„±ì„ ì˜µì…”ë„ì´ ì•„ë‹ˆê²Œ ë§Œë“œëŠ” Required

```ts
type MyRequired<T> = {
  [P in keyof T]-?: T[P];
};

type Result = MyRequired<{ a?: string, b?: number }>;
```

## Readonly

ê°™ì€ ì›ë¦¬ë¡œ ëª¨ë“  ì†ì„±ì„ readonlyë¡œ ë§Œë“¤ê±°ë‚˜ readonlyê°€ ì•„ë‹ˆê²Œ ë§Œë“¤ ìˆ˜ ìˆìŒ.

- ëª¨ë“  ì†ì„± readonly
```ts
type MyReadonly<T> = {
  readonly [P in keyof T]: T[P];
};

type Result = MyReadonly<{ a: string, b: number }>;

/*
type Result = {
  readonly a: string;
  readonly b: number;
}
*/
```

- ëª¨ë“  ì†ì„± readonly ì•„ë‹˜

```ts
type MyReadonly<T> = {
  -readonly [P in keyof T]: T[P];
};

type Result = MyReadonly<{ a: string, b: number }>;
```

## Picked

ê°ì²´ì—ì„œ ì§€ì •í•œ ì†ì„±ë§Œ ì¶”ë¦¬ëŠ” Pick
K íƒ€ì… ë§¤ê°œë³€ìˆ˜ëŠ” T ê°ì²´ì˜ ì†ì„± ì´ë¦„ì´ì–´ì•¼ í•˜ë¯€ë¡œ extends keyof T ì œì•½ì„ ì¤€ ê±° í™•ì¸ ê°€ëŠ¥

```ts
type MyPick<T, K extends keyof T> = {
  [P in K]: T[P];
};

type Result = MyPick<{ a: string, b: number, c: number }, 'a' | 'c'>;
/*
type Result = {
  a: string;
  c: number;
}
*/
```

ì•„ë˜ ê²½ìš°ëŠ” dê°€ ì—†ì–´ì„œ ì—ëŸ¬ ë‚¨.
```ts
type Result = MyPick<{ a: string, b: number, c: number }, 'a' | 'c' | 'd'>;
// Type '"a" | "c" | "d"' does not satisfy the constraint '"a" | "c" | "b"'.
// Type '"d"' is not assignable to type '"a" | "c" | "b"'.
```

ë§¤í•‘ëœ ê°ì²´ íƒ€ì…ê³¼ ì»¨ë””ì…”ë„ íƒ€ì… ê°™ì´ ì‚¬ìš©í•˜ë©´ í•´ê²° ê°€ëŠ¥.
`MyPick<T, K>`ëŠ” `{ [P in 'a' | 'c' | never]: T[P] }` ê°€ ë˜ì–´ ìµœì¢…ì ìœ¼ë¡œ `{ [P in 'a' | 'c']: T[P] }`ê°€ ë˜ì–´ `{ a: string, c: number }`ë§Œ ë‚¨ìŒ.

```ts
type MyPick<T, K> = {
  [P in (K extends keyof T ? K : never)]: T[P];
};

type Result = MyPick<{ a: string, b: number, c: number }, 'a' | 'c' | 'd'>;
```

ê·¸ëŸ¬ë‚˜ Kê°€ dì¸ ê²½ìš°ì—ëŠ” Resultê°€ {} íƒ€ì…ì´ ë˜ì–´ë²„ë¦¬ëŠ” ë¬¸ì œ ìˆìŒ.
{}íƒ€ì…ì€ ëª¨ë“  ê°’ì„ ì˜ë¯¸í•˜ëŠ” ë§Œí¼ ì˜ë„ê°€ ë‹¬ë¼ì§„ ê±°ì„.

```ts
type MyPick<T, K> = {
  [P in (K extends keyof T ? K : never)]: T[P];
};

type Result = MyPick<{ a: string, b: number, c: number }, 'd'>;
// type Result = {}
const result: Result = { a: 'ì´ê²Œ ë˜ë„¤?' };
```

## Record

ëª¨ë“  ì†ì„±ì˜ íƒ€ì…ì´ ë™ì¼í•œ ê°ì²´ì˜ íƒ€ì…ì¸ Record
K extends keyof anyë¥¼ í†µí•´ Kì— string | number | symbolë¡œ ì œì•½ ê±´ê±° í™•ì¸ ê°€ëŠ¥.
ì†ì„± ì´ë¦„ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ì—†ëŠ” ê°’ì„ Kë¡œ ì œê³µí•˜ëŠ” ì‹¤ìˆ˜ ë§‰ì„ ìˆ˜ ìˆìŒ.

```ts
type MyRecord<K extends keyof any, T> = {
  [P in K]: T;
};

type Result = MyRecord<'a' | 'b', string>;
/*
type Result = {
  a: string;
  b: string;
}
*/
```
