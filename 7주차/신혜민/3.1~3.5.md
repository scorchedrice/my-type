# ğŸ“Œ 3.1 Partial, Required, Readonly, Pick, Record


`Partial`, `Required`, `Readonly`, `Pick`, `RecordëŠ”` íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ ê³µì‹ ì‚¬ì´íŠ¸ì˜ `Reference` ì¤‘ `Utility Types`ì—ì„œ ë§¤í•‘ëœ ê°ì²´ íƒ€ì…ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒë§Œ ì¶”ë¦° ê²ƒì´ë‹¤.

## Partial íƒ€ì…
PartialëŠ” ê¸°ì¡´ ê°ì²´ì˜ ì†ì„±ì„ ì „ë¶€ ì˜µì…”ë„ë¡œ ë§Œë“ ë‹¤.

```ts
type MyPartial<T> = {
  [P in keyof T]?: T[P];
};

type Result = MyPartial<{ a: string, b: number }>;
/*
type Result = {
  a?: string | undefined;
  b?: number | undefined;
}
*/
```
ì´ë¦„ ì•ì— Myë¥¼ ë¶™ì´ì§€ ì•Šìœ¼ë©´ lib.es5.d.tsì˜ ì„ ì–¸ê³¼ ì¤‘ë³µë˜ê¸° ë•Œë¬¸ì— ë¶™ì¸ë‹¤.

ë§¤í•‘ëœ ê°ì²´ íƒ€ì…ìœ¼ë¡œ ê¸°ì¡´ ê°ì²´ì˜ ì†ì„±ì„ ê°€ì ¸ì˜¤ë©´ì„œ ì˜µì…”ë„ ìˆ˜ì‹ì–´ë¥¼ ì¶”ê°€ë¡œ ë¶™ì´ê³  ìˆì–´ ëª¨ë“  ê°ì²´ì˜ ì†ì„±ì´ ì˜µì…”ë„ì´ ëœë‹¤.

### ì¼ë¶€ ì†ì„±ë§Œ ì˜µì…”ë„ë¡œ
ë§Œë“¤ ìˆ˜ëŠ” ìˆì§€ë§Œ ë‹¤ìŒ ì ˆì—ì„œ ë°°ìš´ë‹¤.

## Required íƒ€ì…
ëª¨ë“  ì†ì„±ì„ ì˜µì…”ë„ì´ ì•„ë‹ˆê²Œ ë§Œë“ ë‹¤.

```ts
type MyRequired<T> = {
  readonly [P in keyof T]-?: T[P];
};

type Result = MyRequired<{ a?: string, b?: number }>;
/*
type Result = {
  readonly a: string;
  readonly b: number;
}
*/
```
`Partial`ì™€ ê°™ì€ ì›ë¦¬ë¡œ ëª¨ë“  ì†ì„±ì„ `readonly`ë¡œ ë§Œë“¤ê±°ë‚˜ `readonly`ê°€ ì•„ë‹ˆê²Œ í•  ìˆ˜ ìˆë‹¤.

ìœ„ ì½”ë“œëŠ” `readonly`íƒ€ì…ì´ê³ , ëª¨ë“  ì†ì„±ì„ `readonly`ê°€ ì•„ë‹ˆê²Œ ë§Œë“¤ë ¤ë©´ `-readonly`ë¥¼ ëŒ€ì‹  ì ìœ¼ë©´ ëœë‹¤.

## Pick íƒ€ì…
ê°ì²´ì—ì„œ ì§€ì •í•œ ì†ì„±ë§Œ ì¶”ë¦´ ìˆ˜ ìˆë‹¤.

```ts
type MyPick<T, K extends keyof T> = {
  [P in K]: T[P];
};

type Result = MyPick<{ a: string, b: number, c: number }, 'a' | 'c'>;
/*
type Result = {
  a: string;
  c: number;
}
*/
```
`K` íƒ€ì… ë§¤ê°œë³€ìˆ˜ëŠ” `T` ê°ì²´ì˜ ì†ì„± ì´ë¦„ì´ì–´ì•¼ í•˜ë¯€ë¡œ `extends keyof T` ì œì•½ì„ ì£¼ì—ˆë‹¤.
`keyof T`ì¸ `'a' | 'b' | 'c'`ì—ì„œ `'a' | 'c'`ë§Œ ì¶”ë¦´ ìˆ˜ ìˆê²Œ ëœë‹¤.

### ì§€ì •í•œ ì†ì„±ì„ ë³€ê²½í•˜ë ¤ë©´
ë‹¤ìŒ ì ˆì—ì„œ ë°°ìš´ë‹¤.

### ê°ì²´ì˜ ì†ì„±ì´ ì•„ë‹Œ ê²½ìš°ëŠ” ë¬´ì‹œí•˜ê³ , ë‚˜ë¨¸ì§€ ì†ì„±ë§Œ ì¶”ë¦¬ë ¤ë©´

```ts
type MyPick<T, K> = {
  [P in (K extends keyof T ? K : never)]: T[P];
};

type Result = MyPick<{ a: string, b: number, c: number }, 'a' | 'c' | 'd'>;
```
ë§¤í•‘ëœ ê°ì²´ íƒ€ì…ê³¼ ì»¨ë””ì…”ë„ íƒ€ì…ì„ ê°™ì´ ì‚¬ìš©í•˜ë©´ ëœë‹¤.
'a' | 'c' | 'd'ëŠ” ì œë„¤ë¦­(K)ì´ì ìœ ë‹ˆì–¸ì´ë¯€ë¡œ ë¶„ë°°ë²•ì¹™ì´ ì‹¤í–‰ëœë‹¤.
ë¶„ë°°ë²•ì¹™ìœ¼ë¡œ `{ [P in 'a' | 'c']: T[P] }`ê°€ ë˜ì–´ `{ a: string, c: number }`ë§Œ ë‚¨ê²Œ ëœë‹¤.

ì´ ë°©ì‹ì€ ë‹¨ì ì´ ìˆë‹¤.
Kê°€ 'd'ì¸ ê²½ìš°ì—ëŠ” Resultê°€ {} íƒ€ì…ì´ ë˜ì–´ë²„ë¦°ë‹¤.
```ts
type MyPick<T, K> = {
  [P in (K extends keyof T ? K : never)]: T[P];
};

type Result = MyPick<{ a: string, b: number, c: number }, 'd'>;
// type Result = {}
const result: Result = { a: 'ì´ê²Œ ë˜ë„¤?' };
```
{} íƒ€ì…ì€ ê°ì²´ë¥¼ ì˜ë¯¸í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ nullê³¼ undefinedë¥¼ ì œì™¸í•œ ëª¨ë“  ê°’ì„ ì˜ë¯¸í•˜ëŠ” ë§Œí¼, ì˜ë„ê°€ ë‹¬ë¼ì ¸ ë²„ë¦°ë‹¤.

## Record íƒ€ì…
ëª¨ë“  ì†ì„±ì˜ íƒ€ì…ì´ ë™ì¼í•œ ê°ì²´ íƒ€ì…ì´ë‹¤.

```ts
type MyRecord<K extends keyof any, T> = {
  [P in K]: T;
};

type Result = MyRecord<'a' | 'b', string>;
/*
type Result = {
  a: string;
  b: string;
}
*/
```
K extends keyof anyë¥¼ í†µí•´ Kì— string | number | symbolë¡œ ì œì•½ì„ ê±¸ì—ˆë‹¤.

ì œì•½ì€ ì†ì„± ì´ë¦„ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ì—†ëŠ” ê°’ì„ Kë¡œ ì œê³µí•˜ëŠ” ì‹¤ìˆ˜ë¥¼ ë§‰ì„ ìˆ˜ ìˆê¸° ë•Œë¬¸ì— ê°€ëŠ¥í•˜ë©´ ì—„ê²©í•˜ê²Œ ê±°ëŠ” ê²ƒì´ ì¢‹ë‹¤.

---

# ğŸ“Œ 3.2 Exclude, Extract, Omit, NonNullable


ì»¨ë””ì…”ë„ íƒ€ì…ì¼ ë•Œ ìœ ë‹ˆì–¸ì¸ ê¸°ì¡´ íƒ€ì…ê³¼ ì œë„¤ë¦­ì´ ë§Œë‚˜ë©´ ë¶„ë°°ë²•ì¹™ì´ ì‹¤í–‰ëœë‹¤.
ì´ ì ˆì—ì„œ ë°°ìš°ëŠ” íƒ€ì…ì€ ëª¨ë‘ ë¶„ë°°ë²•ì¹™ì„ í™œìš©í•˜ëŠ” íƒ€ì…ì´ë‹¤.

## Exclude íƒ€ì…
ì–´ë– í•œ íƒ€ì…ì—ì„œ ì§€ì •í•œ íƒ€ì…ì„ ì œê±°í•˜ëŠ” íƒ€ì…ì´ë‹¤.
```ts
type MyExclude<T, U> = T extends U ? never : T;
type Result = MyExclude<1 | '2' | 3, string>;
// type Result = 1 | 3
```
`1 | '2' | 3`ì€ ìœ ë‹ˆì–¸ì´ë¯€ë¡œ ë¶„ë°°ë²•ì¹™ì´ ì‹¤í–‰ëœë‹¤.
`MyExclude<1, string> | MyExclude<'2', string> | MyExclude<3, string>`ì´ ë˜ê³ , ë‹¤ì‹œ `(1 extends string ? never : 1) | ('2' extends string ? never : '2') | (3 extends string ? never : 3)`ì´ ë˜ì–´ `1 | never | 3`ì´ ëœë‹¤.

## Extract íƒ€ì…
ì–´ë– í•œ íƒ€ì…ì—ì„œ ì§€ì •í•œ íƒ€ì…ë§Œ ì¶”ì¶œí•˜ëŠ” íƒ€ì…ì´ë‹¤.

```ts
type MyExtract<T, U> = T extends U ? T : never;
type Result = MyExtract<1 | '2' | 3, string>;
// type Result = "2"
```
`Extract` íƒ€ì…ì€ `Exclude` íƒ€ì…ê³¼ í•˜ëŠ” í–‰ë™ì´ ë°˜ëŒ€ì´ë‹¤.
ì»¨ë””ì…”ë„ íƒ€ì…ì˜ ì°¸, ê±°ì§“ ë¶€ë¶„ë§Œ ì„œë¡œ ë°”ê¾¸ë©´ ëœë‹¤.

## Omit íƒ€ì…
íŠ¹ì • ê°ì²´ì—ì„œ ì§€ì •í•œ ì†ì„±ì„ ì œê±°í•˜ëŠ” íƒ€ì…ì´ë‹¤.

```ts
type MyOmit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;
type Result = MyOmit<{ a: '1', b: 2, c: true }, 'a' | 'c'>;
// type Result = { b: 2 }
```
`Omit` íƒ€ì…ì€ `Pick` íƒ€ì…ê³¼ ë°˜ëŒ€ë˜ëŠ” í–‰ë™ì„ í•œë‹¤.
ê·¸ëŸ¬ë©´ì„œ Omit íƒ€ì…ì€ Pickê³¼ Exclude íƒ€ì…ì„ í™œìš©í•œë‹¤.

`Exclude<keyof T, K>`ë¥¼ í•˜ì—¬ ì§€ì •í•œ ì†ì„±ì„ ì œê±°í•´ `'b'`ë§Œ ì¶”ë ¤ì§„ë‹¤.
`Pick` íƒ€ì…ì„ í†µí•´ ê°ì²´ì—ì„œ ì¶”ë ¤ë‚¸ ì†ì„±ì„ ì„ íƒí•´ ìµœì¢…ì ìœ¼ë¡œ `'b'` ì†ì„±ë§Œ ìˆëŠ” ê°ì²´ íƒ€ì…ì´ ë‚¨ê²Œ ëœë‹¤.

## NonNullable íƒ€ì…
`null`ê³¼ `undefined`ë¥¼ ì œê±°í•˜ëŠ” íƒ€ì…ì´ë‹¤.

```ts
type MyNonNullable<T> = T extends null | undefined ? never : T;
type Result = MyNonNullable<string | number | null | undefined>;
// type Result = string | number
```
`T`ê°€ `string | number | null | undefined` íƒ€ì…ì´ë¼ê³  í–ˆì„ ë•Œ ì œë„¤ë¦­ê³¼ ìœ ë‹ˆì–¸ì´ ë§Œë‚¬ìœ¼ë¯€ë¡œ ë¶„ë°°ë²•ì¹™ì´ ì‹¤í–‰ë˜ì–´ `NonNullable<string> | NonNullable<number> | NonNullable<null> | NonNullable<undefined>`ê°€ ëœë‹¤.
ë‹¤ì‹œ `string | number | never | never`ê°€ ë˜ê³ , ìµœì¢…ì ìœ¼ë¡œëŠ” `string | number`ê°€ ëœë‹¤.

í•˜ì§€ë§Œ ìš”ì¦˜ì€ NonNullable íƒ€ì…ì´ ë‹¤ìŒê³¼ ê°™ì´ ë” ê°„ë‹¨í•˜ê²Œ ë³€ê²½ë˜ì—ˆë‹¤.

```ts
type MyNonNullable<T> = T & {};
```
`T`ê°€ `string | number | null | undefined`ë©´ `{}`ëŠ” `string`ê³¼ `number`ëŠ” í¬í•¨í•˜ë‚˜ `null`ê³¼ `undefined`ëŠ” í¬í•¨í•˜ì§€ ì•ŠëŠ”ë‹¤.
`T`ì™€ `{}`ì˜ êµì§‘í•©ì€ `string | number`ì´ë¯€ë¡œ `NonNullable` íƒ€ì…ì´ `T & {}`ë¡œ ê°„ì†Œí™”ë˜ì—ˆë‹¤.

## Optional íƒ€ì…
ì´ì „ ì ˆì—ì„œ ì–¸ê¸‰í–ˆë˜ ì¼ë¶€ ì†ì„±ë§Œ ì˜µì…”ë„ë¡œ ë§Œë“œëŠ” íƒ€ì…ì´ë‹¤.
Optional íƒ€ì…ì€ lib.es5.d.tsì— ìˆëŠ” íƒ€ì…ì´ ì•„ë‹ˆë¯€ë¡œ Myë¥¼ ë¶™ì´ì§€ ì•Šì•„ë„ ëœë‹¤.

```ts
type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>

type Result = Optional<{ a: 'hi', b: 123 }, 'a'>;
// type Result = { a?: 'hi', b: 123 }
```
ì¼ë¶€ ì†ì„±ë§Œ ì˜µì…”ë„ë¡œ ë§Œë“¤ë ¤ë©´ ì˜µì…”ë„ì´ ë  ì†ì„±ê³¼ ì•„ë‹Œ ì†ì„±ì„ êµ¬ë¶„í•´ì•¼ í•œë‹¤.
ì˜µì…”ë„ì´ ë  ì†ì„±ì€ Pickìœ¼ë¡œ ê³ ë¥¸ ë’¤ì— `Partial`ì„ ì ìš©í•˜ê³ `({ a?: 'hi })`, ì•„ë‹Œ ì†ì„±ë“¤ì€ `Omit<T, K>`ë¡œ ì¶”ë¦¬ë©´ ëœë‹¤`({ b : 123 })`
ì´ ë‘˜ì„ `&` ì—°ì‚°ìë¡œ í•©ì¹˜ë©´ `Optional` ì†ì„±ì´ ëœë‹¤.

---

# ğŸ“Œ 3.3 Parameters, ConstructorParameters, ReturnType, InstanceType



## Utility TypesëŠ” inferë¥¼ í™œìš©í•œ íƒ€ì…ë“¤

```ts
type MyParameters<T extends (...args: any) => any>
  = T extends (...args: infer P) => any ? P : never;

type MyConstructorParameters<T extends abstract new (...args: any) => any>
  = T extends abstract new (...args: infer P) => any ? P : never;

type MyReturnType<T extends (...args: any) => any>
  = T extends (...args: any) => infer R ? R : any;

type MyInstanceType<T extends abstract new (...args: any) => any>
  = T extends abstract new (...args: any) => infer R ? R : any;
```
2.22ì ˆì—ì„œ ì‚¬ìš©í–ˆë˜ ì˜ˆì œë¥¼ íƒ€ì… ë§¤ê°œë³€ìˆ˜ Tì— ì—„ë°€í•˜ê²Œ ì œì•½ì„ ê±¸ì–´ë‘ì—ˆë‹¤.

`new (...args: any) => any`ëŠ” í´ë˜ìŠ¤ë¥¼ í¬í•¨í•œ ëª¨ë“  ìƒì„±ì í•¨ìˆ˜ë¥¼ ì˜ë¯¸í•˜ëŠ” íƒ€ì…ì´ë‹¤.
í•˜ì§€ë§Œ ì¶”ìƒ í´ë˜ìŠ¤ëŠ” í¬í•¨í•˜ì§€ ì•ŠëŠ”ë‹¤.

ì¶”ìƒ í´ë˜ìŠ¤ê¹Œì§€ í¬í•¨í•˜ë ¤ë©´ `abstract new (...args: any) => any`ë¡œ íƒ€ì´í•‘í•´ì•¼ í•œë‹¤.

---

# ğŸ“Œ 3.4 ThisType


## ThisType
ë©”ì„œë“œë“¤ì— thisë¥¼ í•œ ë°©ì— ì£¼ì…í•˜ëŠ” íƒ€ì…ì´ë‹¤.

```ts
const obj = {
  data: {
    money: 0,
  },
  methods: {
    addMoney(amount: number) {
      this.money += amount;
    },
    useMoney(amount: number) {
      this.money -= amount;
    }
  }
};
// Property 'money' does not exist on type '{ addMoney(amount: number): void; useMoney(amount: number): void; }'.
// Property 'money' does not exist on type '{ addMoney(amount: number): void; useMoney(amount: number): void; }'.
```
addMoneyë‚˜ useMoney ê°™ì€ ë©”ì„œë“œì—ì„œ thisë¥¼ ì“°ê³  ì‹¶ì€ ìƒí™©ì¸ë° ì´ ì˜ˆì œì—ì„œ thisëŠ” obj ê°ì²´ê°€ ì•„ë‹ˆë¼ dataì™€ methods ê°ì²´ë¥¼ í•©ì¹œ íƒ€ì…ì´ë‹¤.

this.data.money, this.methods.addMoneyê°€ ì•„ë‹ˆë¼ this.money, this.addMoneyë¡œ ì ‘ê·¼í•˜ë ¤ í•œë‹¤.

```ts
type Data = { money: number };
type Methods = {
  addMoney(this: Data & Methods, amount: number): void;
  useMoney(this: Data & Methods, amount: number): void;
};
type Obj = {
  data: Data;
  methods: Methods;
};
const obj: Obj = {
  data: {
    money: 0,
  },
  methods: {
    addMoney(amount) {
      this.money += amount;
    },
    useMoney(amount) {
      this.money -= amount;
    }
  }
};
```
ì•ì„  ì½”ë“œì— íƒ€ì…ì„ ì¶”ê°€í–ˆë‹¤.
ë©”ì„œë“œì— `this`ë¥¼ ì§ì ‘ íƒ€ì´í•‘ í–ˆëŠ”ë°, ì•ìœ¼ë¡œ ì¶”ê°€í•  ëª¨ë“  ë©”ì„œë“œì— thisë¥¼ ì¼ì¼ì´ íƒ€ì´í•‘í•´ì•¼ í•˜ê³  ì¤‘ë³µì´ ë°œìƒí•œë‹¤.

ì´ëŸ´ ë•Œ `ThisType` íƒ€ì…ì„ ì‚¬ìš©í•˜ë©´ ì¤‘ë³µì„ ì œê±°í•  ìˆ˜ ìˆë‹¤.
```ts
type Data = { money: number };
type Methods = {
  addMoney(amount: number): void;
  useMoney(amount: number): void;
};
type Obj = {
  data: Data;
  methods: Methods & ThisType<Data & Methods>;
};
const obj: Obj = {
  data: {
    money: 0,
  },
  methods: {
    addMoney(amount) {
      this.money += amount;
    },
    useMoney(amount) {
      this.money -= amount;
    }
  }
};
```
ë©”ì„œë“œì— ì¼ì¼ì´ íƒ€ì´í•‘í•˜ëŠ” ê²Œ ì•„ë‹ˆë¼, ë©”ì„œë“œë¥¼ ë‹´ê³  ìˆëŠ” ê°ì²´ íƒ€ì…ì¸ Methodsì— ThisType `<Data & Methods>`ë¥¼ ì¸í„°ì„¹ì…˜ í–ˆë‹¤.
ì´ëŸ¬ë©´ thisëŠ” Data & Methodsê°€ ëœë‹¤.
ì¼ì¼ì´ this íƒ€ì´í•‘í•˜ì§€ ì•Šì•„ë„ ë˜ë¯€ë¡œ í¸ë¦¬í•˜ë‹¤.

ThisTypeì€ lib.es5.d.tsì— ì¡´ì¬í•˜ë‚˜ êµ¬í˜„ë˜ì–´ ìˆì§€ ì•Šë‹¤.

```ts
// lib.es5.d.ts
type Uppercase<S extends string> = intrinsic;

type Lowercase<S extends string> = intrinsic;

type Capitalize<S extends string> = intrinsic;

type Uncapitalize<S extends string> = intrinsic;

interface ThisType<T> { }
```
ThisType íƒ€ì…ì€ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ ì½”ë“œë¡œëŠ” êµ¬í˜„í•  ìˆ˜ ì—†ê¸°ì— ë¹„ì–´ ìˆëŠ” ì¸í„°í˜ì´ìŠ¤ë§Œ ì„ ì–¸í•´ ë‹¤ë¥¸ ê³³ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ í•œ ê²ƒì´ë‹¤.

---
# ğŸ“Œ 3.5 forEach ë§Œë“¤ê¸°


ë°°ì—´ì˜ ë©”ì„œë“œë¥¼ ì§ì ‘ íƒ€ì´í•‘í•˜ë©° íƒ€ì…ì„ ë§Œë“œëŠ” ê³¼ì •ì„ ì•Œì•„ë³´ì.

## forEach ë§Œë“¤ê¸°

`forEach` ë©”ì„œë“œëŠ” ì´ë¯¸ `lib.es5.d.ts`ì— ìˆìœ¼ë¯€ë¡œ, ëŒ€ì‹  `forEach`ì™€ ë™ì¼í•œ ê¸°ëŠ¥ì„ í•˜ëŠ” `myForEach`ë¼ëŠ” ë©”ì„œë“œë¥¼ ë§Œë“¤ì—ˆë‹¤.

```ts
[1, 2, 3].myForEach(() => {})
// Property 'myForEach' does not exist on type 'number[]'. Did you mean 'forEach'?
```
ì§€ê¸ˆì€ myForEach ë©”ì„œë“œê°€ ì—†ë‹¤ê³  ì—ëŸ¬ê°€ ë°œìƒí•œë‹¤.
`lib.es5.d.ts`ëŠ” `Array`ë¥¼ ì¸í„°í˜ì´ìŠ¤ë¡œ ë§Œë“¤ì–´ë‘ì—ˆê¸° ë•Œë¬¸ì— ê°™ì€ ì´ë¦„ì˜ ì¸í„°í˜ì´ìŠ¤ë¥¼ ë§Œë“¤ì–´ ë³‘í•©í•  ìˆ˜ ìˆë‹¤.

```ts
[1, 2, 3].myForEach(() => {});
// Expected 0 arguments, but got 1.

interface Array<T> {
  myForEach(): void;
}
```
`Array` ì¸í„°í˜ì´ìŠ¤ë¥¼ ì„ ì–¸í•´ ê¸°ì¡´ ì¸í„°í˜ì´ìŠ¤ë¥¼ ë³‘í•©í–ˆë‹¤.
ì´ë•Œ ì œë„¤ë¦­ íƒ€ì… ë§¤ê°œë³€ìˆ˜ì¸ Tê¹Œì§€ ë™ì¼í•˜ê²Œ ì„ ì–¸í•´ì•¼ í•œë‹¤.
`myForEach(): void`ë¡œ íƒ€ì´í•‘í•˜ë‹ˆ ì¸ìˆ˜ì˜ ê°œìˆ˜ê°€ 0ê°œì—¬ì•¼ í•˜ëŠ”ë° 1ê°œë¥¼ ì œê³µí–ˆë‹¤ëŠ” ì—ëŸ¬ê°€ ë°œìƒí•œë‹¤.

ì¸ìˆ˜ë¥¼ ë„£ì„ ìˆ˜ ìˆê²Œ ë§¤ê°œë³€ìˆ˜ë¥¼ íƒ€ì´í•‘ í–ˆë‹¤.
```ts
[1, 2, 3].myForEach(() => {});

interface Array<T> {
  myForEach(callback: () => void): void;
}
```
ì—ëŸ¬ê°€ ì‚¬ë¼ì¡Œì§€ë§Œ í…ŒìŠ¤íŠ¸ ì‚¬ë¡€ë¥¼ ë§Œë“¤ì–´ ì—ëŸ¬ê°€ ë°œìƒí•˜ëŠ”ì§€ í™•ì¸í•´ì•¼ í•œë‹¤.

```ts
[1, 2, 3].myForEach(() => {});
[1, 2, 3].myForEach((v, i, a) => { console.log(v, i, a) });
// Argument of type '(v: any, i: any, a: any) => void' is not assignable to parameter of type '() => void'.
[1, 2, 3].myForEach((v, i) => console.log(v));
// Argument of type '(v: any, i: any) => void' is not assignable to parameter of type '() => void'.
[1, 2, 3].myForEach((v) => 3);
// Parameter 'v' implicitly has an 'any' type.
// Type 'number' is not assignable to type 'void'.

interface Array<T> {
  myForEach(callback: () => void): void;
}
```
í…ŒìŠ¤íŠ¸ ì‚¬ë¡€ë¥¼ ì¶”ê°€í•˜ë‹ˆ ì—­ì‹œë‚˜ ì—ëŸ¬ê°€ ë°œìƒí•œë‹¤.
`forEach` ë©”ì„œë“œì˜ ì½œë°± í•¨ìˆ˜ëŠ” ë§¤ê°œë³€ìˆ˜ê°€ 3ê°œì´ë©° ìˆœì„œëŒ€ë¡œ `ìš”ì†Œ ê°’`, `ì¸ë±ìŠ¤`, `ì›ë³¸ ë°°ì—´`ì´ë¯€ë¡œ ë§¤ê°œë³€ìˆ˜ë¥¼ íƒ€ì´í•‘í•˜ë©´
```ts
[1, 2, 3].myForEach(() => {});
[1, 2, 3].myForEach((v, i, a) => { console.log(v, i, a) });
[1, 2, 3].myForEach((v, i) => console.log(v));
[1, 2, 3].myForEach((v) => 3);

interface Array<T> {
  myForEach(callback: (v: number, i: number, a: number[]) => void): void;
}
```
ì—ëŸ¬ê°€ í•´ê²°ëœë‹¤.
ë” ë‹¤ì–‘í•œ í…ŒìŠ¤íŠ¸ ì‚¬ë¡€ë¡œ ë°°ì—´ì„ ë‹¤ë¥´ê²Œ í•´ë´¤ë‹¤.
```ts
[1, 2, 3].myForEach(() => {});
[1, 2, 3].myForEach((v, i, a) => { console.log(v, i, a) });
[1, 2, 3].myForEach((v, i) => console.log(v));
[1, 2, 3].myForEach((v) => 3);
['1', '2', '3'].myForEach((v) => {
  console.log(v.slice(0));
});
// Property 'slice' does not exist on type 'number'.
[true, 2, '3'].myForEach((v) => {
  if (typeof v === 'string') {
    v.slice(0);
  } else {
    v.toFixed();
  }
});
// Property 'slice' does not exist on type 'never'.

interface Array<T> {
  myForEach(callback: (v: number, i: number, a: number[]) => void): void;
}
```
ë‹¤ì‹œ ì—ëŸ¬ê°€ ë°œìƒí–ˆê³  `v.toFixed()`ì—ì„œ ì—ëŸ¬ê°€ ë°œìƒí•´ì•¼ í•˜ëŠ”ë° ë°œìƒí•˜ì§€ ì•ŠëŠ” ìƒí™©ë„ ë¬¸ì œë„ ìˆë‹¤.

í˜„ì¬ ë¬¸ì œì˜ ì›ì¸ì€ ê°ê° ìš”ì†Œì™€ ì›ë³¸ ë°°ì—´ì˜ íƒ€ì…ì¸ ë§¤ê°œë³€ìˆ˜ `v`ì™€ `a`ê°€ ëª¨ë‘ `number` ê¸°ë°˜ìœ¼ë¡œ ê³ ì •ë˜ì–´ ìˆê¸° ë•Œë¬¸ì´ë‹¤.
`number` ëŒ€ì‹  ì œë„¤ë¦­ ê¸°ë°˜ìœ¼ë¡œ íƒ€ì…ì„ ìˆ˜ì •í•´ë´¤ë‹¤.

```ts
(...)
[true, 2, '3'].myForEach((v) => {
  if (typeof v === 'string') {
    v.slice(0);
  } else {
    v.toFixed();
  }
});
// Property 'toFixed' does not exist on type 'number | boolean'. Property 'toFixed' does not exist on type 'false'.

interface Array<T> {
  myForEach(callback: (v: T, i: number, a: T[]) => void): void;
}
```
ê¸°ì¡´ ì—ëŸ¬ ë©”ì‹œì§€ëŠ” ì „ë¶€ ì‚¬ë¼ì§€ê³  í…ŒìŠ¤íŠ¸ ì‚¬ë¡€ì— ìˆì—ˆìœ¼ë‚˜ ì¡ì§€ ëª»í–ˆë˜ ì—ëŸ¬ë¥¼ ì œëŒ€ë¡œ ì¡ì•„ë‚´ê¸° ì‹œì‘í•œë‹¤.

ì´ì œ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ê°€ lib.es5.d.tsì—ì„œ íƒ€ì´í•‘í•œ forEach ë©”ì„œë“œë¥¼ í™•ì¸í•´ë³´ì.

```ts
interface Array<T> {
  forEach(callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any): void;
}
```
ê±°ì˜ ë¹„ìŠ·í•˜ì§€ë§Œ `thisArg?: any`ë¼ëŠ” ë‘ ë²ˆì§¸ ë§¤ê°œë³€ìˆ˜ê°€ ë‚¨ì•˜ë‹¤.
`thisArg`ëŠ” ì½œë°± í•¨ìˆ˜ ì„ ì–¸ë¬¸ì—ì„œ `this`ë¥¼ ì‚¬ìš©í•  ë•Œ, `this` ê°’ì„ ì§ì ‘ ë°”ê¿€ ìˆ˜ ìˆê²Œ í•˜ëŠ” ë¶€ë¶„ì´ë‹¤.
`this`ì˜ ê°’ì„ ë°”ê¾¸ì ì•Šìœ¼ë©´ ë¸Œë¼ìš°ì €ì• ì„œ `this`ê°€ `window`ê°€ ë˜ê³  `Node.js`ì• ì„œëŠ” `global`, `strict`ëª¨ë“œì—ì„œëŠ” `undefined`ê°€ ëœë‹¤.
ì´ì²˜ëŸ¼ íƒ€ì… ì„ ì–¸ì„ ì‚´í´ë³´ë‹¤ ë³´ë©´ ë¯¸ì²˜ ì•Œì§€ ëª»í–ˆë˜ ì‚¬ìš©ë²•ì„ ë°œê²¬í•˜ê¸°ë„ í•œë‹¤.

ì¬ë¯¸ìˆëŠ” ì ì€  lib.es5.d.tsì˜ íƒ€ì´í•‘ì„ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•˜ë©´ thisì—ì„œ ì—ëŸ¬ê°€ ë°œìƒí•œë‹¤.

```ts
[1, 2, 3].forEach(function() {
  console.log(this);
});
// 'this' implicitly has type 'any' because it does not have a type annotation.
```
lib.es5.d.tsì˜ íƒ€ì´í•‘ì´ ì™„ë²½í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— thisì˜ íƒ€ì…ì´ numberë¡œ ì¶”ë¡ ë˜ì§€ ì•ŠëŠ”ë‹¤.
myForEachì—ì„œëŠ” this íƒ€ì´í•‘ì´ ì œëŒ€ë¡œ ë˜ê²Œ íƒ€ì…ì„ ìˆ˜ì •í•´ë³´ì.

```ts
(...)
[1, 2, 3].myForEach(function() {
  console.log(this);
});
// this: Window
[1, 2, 3].myForEach(function() {
  console.log(this);
}, { a: 'b' });
/*
this: {
    a: string;
}
*/
interface Array<T> {
  myForEach<K = Window>(callback: (this: K, v: T, i: number, a: T[]) => void, thisArg?: K): void;
}
```
íƒ€ì… ë§¤ê°œë³€ìˆ˜ `K`ë¥¼ ì„ ì–¸í–ˆë‹¤.
íƒ€ì… ë§¤ê°œë³€ìˆ˜ë¥¼ ì„ ì–¸í•  ìˆ˜ ìˆëŠ” ìë¦¬ëŠ” `Array<T, K>`ì™€ `myForEach<K>`ì¸ë°, `Array<T, K>`ë¥¼ `lib.es5.d.ts`ì— ìˆëŠ” ë°°ì—´ì˜ ì¸í„°í˜ì´ìŠ¤ì™€ íƒ€ì… ë§¤ê°œë³€ìˆ˜ê°€ ë™ì¼í•´ì•¼ í•˜ê¸° ë•Œë¬¸ì— ìˆ˜ì •í•  ìˆ˜ ì—†ìœ¼ë¯€ë¡œ `myForEach<K>` ìë¦¬ì— ì„ ì–¸í–ˆë‹¤.

`myForEach<K = Window>`ë¡œ ì„ ì–¸í–ˆê¸°ì— `thisArg`ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ë©´ `this`ì˜ íƒ€ì…ì€ `Window`ì´ë‹¤.
`thisArg`ë¥¼ ì‚¬ìš©í•˜ë©´ í•´ë‹¹ ê°’ì˜ íƒ€ì…ì´ `this`ì˜ íƒ€ì…ì´ ëœë‹¤.
ì‹¤í–‰ í™˜ê²½ì— ë”°ë¼ `this`ê°€ ë³€í•˜ê¸° ë•Œë¬¸ì— 100% ì •í™•í•œ íƒ€ì…ì„ ì •ì˜í•˜ê¸° ì–´ë µë‹¤.
íƒ€ì…ì´ ì •í™•í•œì§€ í™•ì¸í•˜ëŠ” ë°©ë²•ì€ ë‹¤ì–‘í•œ í…ŒìŠ¤íŠ¸ ì‚¬ë¡€ë¥¼ ë§Œë“¤ì–´ë³´ê³ , ë¬¸ì œê°€ ìƒê¸°ë©´ ìˆ˜ì •í•˜ëŠ” ê²ƒì´ë‹¤.
`myMap`ì´ ì‹¤ì œë¡œ êµ¬í˜„ë˜ì§€ ì•Šì€ ê²½ìš°ì²˜ëŸ¼ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì—ì„œ íƒ€ì… ì—ëŸ¬ê°€ ì—†ì–´ë„ ì‹¤ì œ ì‹¤í–‰ì´ ë³´ì¥ë˜ì§€ëŠ” ì•ŠëŠ”ë‹¤.
