# 📌 2.3 값 자체가 타입인 리터럴 타입이 있다.

>- [리터럴타입이란](#리터럴타입이란)
>  - [객체에서의 리터럴타입](#객체에서의-리터럴타입)
>  - [함수에서의 리터럴타입](#함수에서의-리터럴타입)
>- [결론](#결론)

## 리터럴타입이란

리터럴타입은 정확한 값을 지정하여 더 엄격하게 타입을 지정하는 것이다.

`const`로 원시자료형 타입의 값을 선언하여 변동 가능성이 없는 경우엔 타입스크립트가 이를 자연스럽게 활용하여 추론한다.

```ts
let food: "pizza" = "pizza";
// food = "chicken"; // ❌ 타입 오류 발생
```

만약 리터럴 타입을 선언한다면 위의 예시처럼 `let`으로 변수를 대입하여도 값이 바뀔 수 없다.

### 객체에서의 리터럴타입

`const`로 원시자료형 타입의 변수를 선언하면 자연스럽게 리터럴 타입이 추론되었다.

하지만 객체의 경우 이와 다른 동작을 한다.

```ts
const obj1 = { name: 'han' } // name : string
const obj2 : { name: 'han' } = { name: 'han' }; // name : 'han'
```

이는 객체가 `const`로 선언되어도 값이 바뀔 가능성이 있기 때문이다.

배열또한 동일한 타입추론이 진행된다.

이를 해결하기 위해 타입 단언을 사용할 수 있다.

```ts
const obj = {name: 'han'} as const // const obj : {readonly name : 'han'}
```

`as const`를 활용하여 타입을 단언하면 `readonly`특성이 추가된 리터럴 객체 타입이 추론된다.

또한 단언하면 `key-value`, 요소가 추가되는 것이 불가능하다.

이와 같은 단언은 개발자의 책임과 연결되어있기에 값이 변하지 않는 것이 확실할 때 사용해야한다.

### 함수에서의 리터럴타입

함수에서 리터럴 타입을 선언하는 방식은 위에서 다룬 방식과 차이가있다.

`:`가 아닌 `=>`를 사용해야한다.

```ts
const func: (a: string, b: string) => string 
    = (a,b) => { return a+b }
```

# 💡결론

- 타입추론에서 타입스크립트는 변동 가능성이 없는 경우에 리터럴타입을 추론한다.
  - 객체 유형은 변동 가능성이 있기에 리터럴타입보다 넓은 범위로 타입을 추론한다.
    - 단언(`as const`)를 사용하여 리터럴타입 추론으로 유도할 수 있다.
- 함수에서의 리터럴타입 선언은 일반적인 방식과 차이가 있다.

# 📚 Ref

- 본 문서는 `조현영. (2023). 타입스크립트 교과서. 길벗`을 학습하고 요약 정리하였습니다.