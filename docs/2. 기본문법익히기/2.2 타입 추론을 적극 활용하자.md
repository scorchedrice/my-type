# 📌 2.2 타입 추론을 적극 활용하자

> - [타입추론이란](#타입추론이란)
>   - [ImplicityAny 에러](#implicityany-에러)
> - [타입 넓히기](#타입-넓히기)
>   - [리터럴타입](#리터럴타입)
> - [타입추론 얼마나 믿어야할까?](#타입추론을-얼마나-믿어야할까)
> - [결론](#결론)

## 타입추론이란

타입스크립트는 어느정도 타입을 스스로 추론할 수 있다. 이를 통해 개발자가 불필요한 반복선언하는 것을 방지한다.

함수를 정의할 때, 매개변수에 타입을 선언하면 이에 따라 결론을 추론한다.

```ts
function connectWord(x: string, y: string) : string {
  return x + y
}

const result = connectWord('Hello', 'World') // connectWord 함수의 return 타입이 string임이 명확하니 : string을 붙히지 않아도 된다.
const result2 : string = connectWord('Hello', 'TypeScript') // 뭐 붙혀도 상관없긴하다.
```

### ImplicityAny 에러

만약 함수의 매개변수에 타입선언이 없다면 타입스크립트는 이를 어떻게 추론할까?

결론부터 말하면 `ImplicityAny`에러가 발생한다. 매개변수들이 암묵적으로 `any`로 추론된다는 에러이다.

여기서 암묵적으로 `any`로 추론된다는 것은 다음과 같다.

```ts
// 타입을 명시해주지 않으면 아래처럼 추론한다. (그래서 에러)
// 물론 아래처럼 진짜로 any 선언하면 에러가 없어지겠지만, 이러면 사용하는 이유가 없다!
function test(a : any, b : any) : any {
  return a+b
}
```

## 타입 넓히기

타입을 추론할 때 같은 값으로 변수를 선언해도 다르게 추론되는 경우가 있다. 아래 예시를 통해 확인하자.

```ts
const str1 : string = 'hi'; // str1: string
const str2 = 'hi'; // str2: 'hi'
let str3 = 'hi'; // str3: string
var str4 = 'hi'; // str4: string
```

왜 차이가있을까?

변동 가능성을 타입스크립트가 고려하기 때문이다. 변동 가능성을 고려한 타입추론(`str2`, `str3`, `str4`에 해당)에 따라 다르게 추론되는 것이 타입넓히기이다.

`let`, `var`의 경우엔 값이 바뀔 수 있기에 `string`이라고 추론한다.(`str1`의 경우엔 `string`으로 선언했기에 `string`으로 추론된다.)

반면 `const`로 선언한 `str2`의 경우엔 값이 바뀔 수 없기에 `'hi'`라고 추론한다.

특이사항으론 let에 `null`, `undefined`를 대입하면 `any`로 추론된다.

### 리터럴타입

타입으로 `string`, `number`와 같은 원시자료형을 사용할 수 있지만, `'hi'`와 같은 구체적인 값 또한 사용할 수 있다.

## 타입추론을 얼마나 믿어야할까?

[타입 넓히기](#타입-넓히기)를 보면 알 수 있듯 타입추론을 사용하지 않고 `string`으로 개발자가 선언한 경우, 타입스크립트보다 넓은 범위로 선언한 것을 알 수 있다.

즉, **타입스크립트의 추론이 정확할 때가 많기에** 타입추론과 타입넓히기를 적극 활용하자. 타입스크립트의 추론이 틀리다면, 그 때 올바른 타입을 표기하자.

# 💡결론

- 타입추론과 타입 넓히기를 적극 활용하자!

# 📚 Ref

- 본 문서는 `조현영. (2023). 타입스크립트 교과서. 길벗`을 학습하고 요약 정리하였습니다.
