#### **π“ κ°μ”**

`infer` μμ•½μ–΄λ” TypeScriptμ—μ„ νƒ€μ… μ¶”λ΅  κΈ°λ¥μ„ μµλ€ν• ν™μ©ν•κΈ° μ„ν• κΈ°λ¥μ΄λ‹¤. λ³΄ν†µ `μ΅°κ±΄λ¶€ νƒ€μ…(Conditional Types)`κ³Ό ν•¨κ» μ‚¬μ©λλ©°, νΉμ • νƒ€μ…μ„ μ¶”μ¶ν•λ” λ° λ„μ›€μ„ μ¤€λ‹¤.

---

#### **π” μ£Όμ” λ‚΄μ©**

#### β… κΈ°λ³Έμ μΈ infer μ‚¬μ©λ²•

`infer`λ” νΉμ • νƒ€μ…μ„ μ¶”λ΅ ν•κ³  μ‹¶μ€ λ¶€λ¶„μ„ `infer νƒ€μ…λ³€μ`λ΅ ν‘μ‹ν•λ©΄ λλ‹¤. λ‹¤μ μμ λ” `λ°°μ—΄`μ΄ μμ„ λ•, ν•΄λ‹Ή λ°°μ—΄μ μ”μ† νƒ€μ…μ„ μ¶”λ΅ ν•λ” λ°©μ‹μ΄λ‹¤.
```
type E1<T> = T extends (infer E)[] ? E : never; 
type Str = E1<string[]>; 
type Str = string type NumOrBool = E1<(number | boolean)[]>; 
type NumOrBool = number | boolean
```



#### β… μ΅°κ±΄λ¶€ νƒ€μ…μ—μ„μ infer μ‚¬μ©

`infer`λ¥Ό μ‚¬μ©ν•λ©΄ νƒ€μ…μ„ μ μ—°ν•κ² μ¶”λ΅ ν•  μ μμ§€λ§, μλ» μ‚¬μ©ν•λ©΄ μ¤λ¥κ°€ λ°μƒν•  μ μλ‹¤.

```
type E1<T> = T extends (infer E)[] ? never : E;  

// 'Cannot find name E' μ¤λ¥ λ°μƒ
```


#### β… λ‹¤μ–‘ν• νƒ€μ… μ¶”λ΅  ν™μ© μμ 

1. **λ§¤κ°λ³€μ νƒ€μ… μ¶”λ΅ **
```
type MyParameters<T> = T extends (...args: infer P) => any ? P : never; 
type P = MyParameters<(a: string, b: number) => string>;  
type P = [a: string, b: number]
```
    
    
2. **μƒμ„±μ λ§¤κ°λ³€μ μ¶”λ΅ **
```
type MyConstructorParameters<T> = T extends abstract new (...args: infer P) => any ? P : never; 

type CP = MyConstructorParameters<new (a: string, b: number) => {}>;  
// type CP = [a: string, b: number]
```
    
    
3. **λ°ν™κ°’ νƒ€μ… μ¶”λ΅ **
```
type MyReturnType<T> = T extends (...args: any) => infer R ? R : any; 

type R = MyReturnType<(a: string, b: number) => string>;  // type R = string
```
    
    
4. **μΈμ¤ν„΄μ¤ νƒ€μ… μ¶”λ΅ **
```
type MyInstanceType<T> = T extends abstract new (...args: any) => infer R ? R : any; 
    
type I = MyInstanceType<new (a: string, b: number) => {}>;  // type I = {}
```

#### β… νƒ€μ… μ΄λ¦„ μ¤‘λ³µ μ¤λ¥ λ°μƒ κ°€λ¥μ„±

μ΄λ―Έ μ΅΄μ¬ν•λ” νƒ€μ… μ΄λ¦„μ„ `infer`μ—μ„ μ‚¬μ©ν•λ©΄ TypeScriptμ λ‚΄λ¶€ μ •μλ νƒ€μ…κ³Ό μ¶©λμ΄ λ°μƒν•  μ μλ‹¤.
```
type Parameters<T> = T extends (...args: infer P) => any ? P : never;   
// μ¤λ¥ λ°μƒ: 'Parameters'λ” μ΄λ―Έ lib.es5.d.tsμ—μ„ μ •μλ νƒ€μ…κ³Ό μ¶©λν•¨
```


#### β… μ—¬λ¬ νƒ€μ… λ³€μ μ¶”λ΅ 

μ„λ΅ λ‹¤λ¥Έ νƒ€μ… λ³€μλ¥Ό λ™μ‹μ— μ¶”λ΅ ν•  μλ„ μλ‹¤.
```
type MyPAndR<T> = T extends (...args: infer P) => infer R ? [P, R] : never; 

type PR = MyPAndR<(a: string, b: number) => string>;  
// type PR = [[a: string, b: number], string]
```


#### β… `Union`κ³Ό `Intersection` νƒ€μ… μ¶”λ΅ 

`infer`λ¥Ό ν™μ©ν•μ—¬ μ λ‹μ¨(Union)κ³Ό μΈν„°μ„Ήμ…(Intersection) νƒ€μ…μ„ μ¶”μ¶ν•  μλ„ μλ‹¤.
```
type Union<T> = T extends { a: infer U; b: infer U } ? U : never; 

type Result1 = Union<{ a: 1, b: 2 } | { a: 1, b: 3 }>;  // type Result1 = 1 | 2 | 3
```

```
type Intersection<T> = T extends {
	a: (pa: infer U) => void; 
	b: (pb: infer U) => void 
} ? U : never; 

type Result2 = Intersection<{ a: (pa: 1) => void, b: (pb: 2) => void }>; 
// type Result2 = 2
```



#### β… `return`κ³Ό `parameter`μ μ°¨μ΄

λ§¤κ°λ³€μ νƒ€μ…κ³Ό λ°ν™κ°’ νƒ€μ…μ΄ λ‹¤λ¥Ό κ²½μ° μ–΄λ–»κ² μ¶”λ΅ λλ”μ§€ μ‚΄ν΄λ³Ό μ μλ‹¤.
```
type ReturnAndParam<T> = T extends { 
	a: () => infer U, 
	b: (pb: infer U) => void 
} ? U : never; 

type Result3 = ReturnAndParam<{ a: () => 1, b: (pb: 1 | 2) => void }>;  
// type Result3 = 1 

type Result4 = ReturnAndParam<{ a: () => 1, b: (pb: 2 | 3) => void }>;  
// type Result4 = never
```


#### β… `Union`κ³Ό `Intersection` νƒ€μ… λ³€ν™ ν™μ©

μ λ‹μ¨μ„ μΈν„°μ„Ήμ…μΌλ΅ λ³€ν™ν•λ” νƒ€μ…μ„ μ‘μ„±ν•  μλ„ μλ‹¤.
```
type UnionToIntersection<U> = (U extends any ? (p: infer I) => void : never) extends ((p: infer R) => void) ? R : never;  

type Result5 = UnionToIntersection<{ a: number } | { b: string }>;  
// type Result5 = { a: number } & { b: string }  


type Result6 = UnionToIntersection<boolean | true>; 
// type Result6 = never
```


---

#### **π“ μ‹¤λ¬΄ μ μ© ν¬μΈνΈ**

π’΅ `infer`λ” TypeScriptμ κ°•λ ¥ν• νƒ€μ… μ¶”λ΅  κΈ°λ¥μ„ ν™μ©ν•  μ μκ² ν•΄μ¤€λ‹¤.  
π’΅ μ λ„¤λ¦­κ³Ό μ΅°κ±΄λ¶€ νƒ€μ…κ³Ό ν•¨κ» μ‚¬μ©ν•λ©΄ λ”μ± μ μ—°ν• νƒ€μ… μ‹μ¤ν…μ„ λ§λ“¤ μ μλ‹¤.  
π’΅ κΈ°μ΅΄μ νƒ€μ…μ„ μ¶”μ¶ν•μ—¬ μ¬μ‚¬μ©ν•λ” λ°©μ‹μΌλ΅ ν™μ©ν•λ©΄ μ½”λ“ μ¤‘λ³µμ„ μ¤„μ΄κ³  μ μ§€λ³΄μλ¥Ό μ‰½κ² ν•  μ μλ‹¤.  
π’΅ `Union`κ³Ό `Intersection` νƒ€μ…κ³Ό ν•¨κ» ν™μ©ν•λ©΄ λ”μ± μ •λ°€ν• νƒ€μ… μ¶”λ΅ μ΄ κ°€λ¥ν•λ‹¤.

---

#### **π“ κ²°λ΅ **

- `infer`λ” μ΅°κ±΄λ¶€ νƒ€μ…(Conditional Types)κ³Ό ν•¨κ» μ‚¬μ©λμ–΄ νΉμ • νƒ€μ…μ„ μ¶”λ΅ ν•λ” λ° μ μ©ν•λ‹¤.
- λ§¤κ°λ³€μ, λ°ν™κ°’, μƒμ„±μ νƒ€μ… λ“±μ„ μ μ—°ν•κ² μ¶”λ΅ ν•λ” λ° μ‚¬μ©ν•  μ μλ‹¤.
- κΈ°μ΅΄ νƒ€μ…μ—μ„ νΉμ • νƒ€μ…μ„ μ¶”μ¶ν•λ” λ°©μ‹μΌλ΅ μ½”λ“μ μ¬μ‚¬μ©μ„±μ„ λ†’μΌ μ μλ‹¤.
- λ³µμ΅ν• μ λ‹μ¨ λ° μΈν„°μ„Ήμ… νƒ€μ…μ„ ν™μ©ν•λ©΄ λ”μ± μ •λ°€ν• νƒ€μ…μ„ κµ¬ν„ν•  μ μλ‹¤.