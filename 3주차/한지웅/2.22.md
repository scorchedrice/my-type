# π“ 2.22 inferλ΅ νƒ€μ…μ¤ν¬λ¦½νΈμ μ¶”λ΅ μ„ μ§μ ‘ ν™μ©ν•μ.

> - [inferμ΄λ€](#inferμ΄λ€)
>   - [inferμ€ μ—¬λ¬κ°λ¥Ό μ‚¬μ©ν•  μ μλ‹¤.](#inferμ€-μ—¬λ¬κ°λ¥Ό-μ‚¬μ©ν• -μ-μλ‹¤)
>   - [μ λ‹μ¨μ„ μΈν„°μ„Ήμ…μΌλ΅](#μ λ‹μ–Έμ„-μΈν„°μ„Ήμ…μΌλ΅)

## inferμ΄λ€

μ‰½κ²λ§ν•΄ νƒ€μ…μ„ μ λ„¤λ¦­μΌλ΅ λ„κΈ°κ³  ν•΄λ‹Ή νƒ€μ…κ³Ό κ΄€λ ¨λ μ¶”λ΅ κ°’μ„ λ°”νƒ•μΌλ΅ μƒλ΅μ΄ νƒ€μ…μ„ λ°ν™ν•λ” κ²ƒμ„ μλ―Έν•λ‹¤.

```ts
type El<T> = T extends (infer E)[] ? E : never;
// Tλ¥Ό λ„κΈΈ λ• E[]λ΅ μ¶”λ΅ λλ‹¤λ©΄ Eλ¥Ό λ‚΄λ†“μ•„λΌ

type STR = El<string[]>; // string
type NumOrBool = El<(string | boolean)[]>; // string | boolean
```

λ, νƒ€μ…μ¤ν¬λ¦½νΈμ νƒ€μ…μ¶”λ΅ μ€ λ§¤κ°λ³€μ, μƒμ„±μ λ§¤κ°λ³€μ, μΈμ¤ν„΄μ¤ νƒ€μ…, λ°ν™κ°’ λ“± λ‹¤μ–‘ν• μ¶”λ΅ μ΄ κ°€λ¥ν•λ‹¤.

```ts
type MyParameters<T> = T extends (...args: infer P) => any ? P : never;
type P = MyParameters<(a: string, b: number) => string> // type P = [a: string, b: number]

type MyConstructorParameters<T> = T extends abstract new (...args: infer P) => any ? P : never;
type CP = MyConstructorParameters<new (a: string, b: number) => {}> // type CP = [a: string, b: number]

type MyReturnType<T> = T extends (...args: any) => infer R ? R : any;
type R = MyReturnType<(a: string, b: number) => string> // type R = string

type MyInstanceType<T> = T extends abstract new (...args: any) => infer R ? R : any;
type I = MyInstanceType<new (a: string, b: number) => {}> // type I = {}
```

### inferμ€ μ—¬λ¬κ°λ¥Ό μ‚¬μ©ν•  μ μλ‹¤.

inferμ€ μ—¬λ¬κ°λ¥Ό λ™μ‹μ— μ‚¬μ©ν•  μ μλ‹¤.

```ts
type MyPAndR<T> = T extends (...args: infer P) => infer R ? [P, R] : never;
type PR = MyPAndR<(a:string, b:number) => string> // type PR = [[a: number, b: string], string]
```

λ, λ™μΌν• νƒ€μ… λ³€μλ¥Ό μ—¬λ¬λ² μ‘μ„±ν•  μ μλ”λ° μ•„λμ μμ‹λ¥Ό ν†µν•΄ ν™•μΈν•μ.

```ts
type Union<T> = T extends {a:infer U, b: infer U} ? U : never;
type R1 = Union<{a: 1|2, b: 2|3}> // type R1 = 1|2|3

type Intersection<T> = T extends {
  a: (pa: infer U) => void,
  b: (pb: infer U) => void
} ? U : never;
type R2 = Intersection<{a(pa:1|2): void, b(pb:2|3): void}>; // type R2 = 2
```

μΌλ°μ μΈ κ²½μ°μ—” νƒ€μ…μ΄ μ λ‹μ–Έλμ—μ§€λ§ λ§¤κ°λ³€μμ κ²½μ°μ—” λ°κ³µλ³€μ„±μ„ μ§€λ…€ νƒ€μ…μ΄ μΈν„°μ„Ήμ… λμ—λ‹¤.

λ°ν™κ°’ νƒ€μ…μ„ κ°™μ€ λ³€μλ΅ μ„ μ–Έν• κ²½μ°μ—” κ³µλ³€μ„±μ„ μ§€λ…€ μ λ‹μ–Έλλ‹¤.

κ·Έλ ‡λ‹¤λ©΄ ν•λ‚κ°€ λ§¤κ°λ³€μκ³ , ν•λ‚κ°€ λ°ν™κ°’μΈ κ²½μ°λ” μ–΄λ–»κ² λ κΉ?

```ts
type RAndP<T> = T extends {
  a: () => infer U,
  b: (pb: infer U) => void
} ? U : never;

type RP1 = RAndP<{a:()=>1|2, b(pb:1|2|3):void}> // 1|2
type RP2 = RAndP<{a:()=>1|2, b(pb:2|3):void}> // never
```

λ°ν™κ°’μ νƒ€μ…μ΄ λ§¤κ°λ³€μ νƒ€μ…μ λ¶€λ¶„μ§‘ν•©μΈ κ²½μ°μ—λ§ κ·Έ λ‘μ κµμ§‘ν•©μ΄ λλ‹¤. κ·Έ μ™Έμ κ²½μ°μ—” neverκ°€ λλ‹¤.

`RP1`μ κ²½μ°μ—” 1|2|3μ λ¶€λ¶„μ§‘ν•©μΈ 1|2κ°€ λκ³ , `RP2`μ κ²½μ° 1|2λ” 2|3 μ λ¶€λ¶„μ§‘ν•©μ΄ μ•„λ‹λ―€λ΅ neverμ΄ λλ‹¤.

### μ λ‹μ–Έμ„ μΈν„°μ„Ήμ…μΌλ΅

μ„μ—μ„ ν•™μµν• λ‚΄μ©μ„ λ°”νƒ•μΌλ΅ μ λ‹μ–Έμ„ μΈν„°μ„Ήμ…μΌλ΅ λ°”κΎΈλ” νƒ€μ΄ν•‘μ„ ν•  μ μλ‹¤.

```ts
type UtoI<U> = (U extends any ? (p: U) => void : never) extends (p: infer I) => void ? I : never;
type UI1 = UtoI<{a:number} | {b:string}> // type UI1 = { a: number } & { b: string}
type UI2 = UtoI<boolean | true> // never
```

μ°μ„ , μ΄λ¥Ό μ΄ν•΄ν•κΈ°μ„ν•΄μ„  λ¶„λ°°λ²•μΉ™μ΄ μΌμ–΄λ‚¨μ„ μ΄ν•΄ν•΄μ•Όν•λ‹¤.

λ¶„λ°°λ²•μΉ™μ΄ μΌμ–΄λ‚ ν›„ κ°κ°μ€ μ„μ λ΅μ§μ— λ”°λΌ νƒ€μ…μ΄ μ¶”λ΅ λμ–΄ μΈν„°μ„Ήμ…λλ‹¤. 
- `UI1`μ κ²½μ°μ—” {a:number} κ³Ό {b:string}μ΄ μΈν„°μ„Ήμ…λ κ°’μ΄ μ¶”λ΅ λλ‹¤.
- `UI2`μ κ²½μ°μ—” true | false | trueκ°€ λ¶„λ°°λμ–΄ μΈν„°μ„Ήμ…κ°’μ΄ μ—†λ” neverκ°€ μ¶”λ΅ λλ‹¤.


# π’΅κ²°λ΅ 

- inferλ” νƒ€μ…μ¶”λ΅ μ„ κ·Ήλ€ν™”ν•λ” κΈ°λ¥μ„ μ κ³µν•λ‹¤.
  - ν•λ‚, λ‘κ°, κ°™μ€ λ³€μμ— λ€ν•΄ μ‚¬μ© κ°€λ¥ν•λ‹¤.
  - μ λ‹μ–Έκ³Ό μΈν„°μ„Ήμ… λ“±μ κ°λ…μ— λ€ν• μ΄ν•΄κ°€ μ„ ν–‰λμ–΄μ•Όν•λ‹¤.

# π“ Ref

- λ³Έ λ¬Έμ„λ” `μ΅°ν„μ. (2023). νƒ€μ…μ¤ν¬λ¦½νΈ κµκ³Όμ„. κΈΈλ²—`μ„ ν•™μµν•κ³  μ”μ•½ μ •λ¦¬ν•μ€μµλ‹λ‹¤.