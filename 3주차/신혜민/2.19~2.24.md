## 2.19 ê³µë³€ì„±ê³¼ ë°˜ ê³µë³€ì„±ì„ ì•Œì•„ì•¼ í•¨ìˆ˜ë¼ë¦¬ ëŒ€ì…í•  ìˆ˜ ìˆë‹¤

>**ê³µë³€ì„±** : `A â†’ B`ì¼ ë•Œ `T<A> â†’ T<B>`ì¸ ê²½ìš°
>**ë°˜ê³µë³€ì„±** : `A â†’ B`ì¼ ë•Œ  `T<B> â†’ T<A>`ì¸ ê²½ìš°
>**ì´ë³€ì„±** : `A â†’ B`ì¼ ë•Œ `T<A> â†’ T<B>`ë„ ë˜ê³  `T<B> â†’ T<A>`ë„ ë˜ëŠ” ê²½ìš°
> **ë¬´ê³µë³€ì„±** : `A â†’ B`ì¼ ë•Œ `T<A> â†’ T<B>`ë„ ì•ˆ ë˜ê³  `T<B> â†’ T<A>`ë„ ì•ˆ ë˜ëŠ” ê²½ìš°

- ê¸°ë³¸ì ìœ¼ë¡œ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ëŠ” **ê³µë³€ì„±**ì„ ê°€ì§€ê³  ìˆì§€ë§Œ, í•¨ìˆ˜ì˜ ë§¤ê°œë³€ìˆ˜ëŠ” **ë°˜ê³µë³€ì„±**ì„ ê°–ê³  ìˆìŒ

```ts
function a(x: string): number {
  return 0;
}
type B = (x: string) => number | string;
let b: B = a;
```
- ìœ„ ì½”ë“œì—ì„œ `b`ê°€ `a`ë³´ë‹¤ **ë„“ì€ íƒ€ì…**, `a â†’ b`ë¼ê³  í•  ìˆ˜ ìˆìŒ

- `T íƒ€ì…`ì„ `í•¨ìˆ˜<ë°˜í™˜ê°’>`ì´ë¼ê³  ìƒê°í•˜ë©´ `a â†’ b`ì¼ ë•Œ `T<A> â†’ T<B>`ê°€ ë¨

- ë”°ë¼ì„œ í•¨ìˆ˜ì˜ ë°˜í™˜ê°’ì€ **ê³µë³€ì„±**ì„ ê°–ê³  ìˆë‹¤ê³  ë³¼ ìˆ˜ ìˆìŒ

```ts
function a(x: string | number): number {
  return 0;
}
type B = (x: string) => number;
let b: B = a;
```

### ë§¤ê°œë³€ìˆ˜ëŠ” strict ì˜µì…˜ì—ì„œ ë°˜ê³µë³€ì„±ì„ ê°€ì§

```ts
function a(x: string | number): number {
  return 0;
}
type B = (x: string) => number;
let b: B = a;
```
- ìœ„ ì½”ë“œëŠ” `b â†’ a`ì¸ ìƒí™©ì¸ë° `a`ë¥¼ `b`ì— ëŒ€ì…í•  ìˆ˜ ìˆìŒ

- `b â†’ a`ì—ì„œ `T<A> â†’ T<B>`ì´ë¯€ë¡œ ë§¤ê°œë³€ìˆ˜ê°€ **ë°˜ê³µë³€ì„±**ì„ ê°€ì§€ê³  ìˆìŒ

> ë§¤ê°œë³€ìˆ˜ëŠ” strict ì˜µì…˜ì¼ ë•Œ **ë°˜ê³µë³€ì„±**, strict ì˜µì…˜ì´ ì•„ë‹ ë•ŒëŠ” **ì´ë³€ì„±**ì„ ê°€ì§. ì´ë³€ì„±ì„ ê°€ì§€ëŠ” ì´ìœ ëŠ” `b â†’ a`ì¼ ë•Œ `T<B> â†’ T<A>`ë„ ë˜ê³  `T<A> â†’ T<B>`ë„ ë˜ê¸° ë•Œë¬¸

### ê°ì²´ì˜ ë©”ì„œë“œ íƒ€ì´í•‘ ë°©ë²•ê³¼ ë³€ì„±

```ts
interface SayMethod {
  say(a: string | number): string;
}
interface SayFunction {
  say: (a: string | number) => string;
}
interface SayCall {
  say: {
    (a: string | number): string
  }
}
const sayFunc = (a: string) => 'hello';
const MyAddingMethod: SayMethod = {
  say: sayFunc //ì´ë³€ì„±
}
const MyAddingFunction: SayFunction = {
  say: sayFunc //ë°˜ê³µë³€ì„±
}
const MyAddingCall: SayCall = {
  say: sayFunc //ë°˜ê³µë³€ì„±
}
// Type '(a: string) => string' is not assignable to type '(a: string | number) => string'. Types of parameters 'a' and 'a' are incompatible. Type 'string | number' is not assignable to type 'string'. Type 'number' is not assignable to type 'string'.
```
- <span style="color:yellowgreen"> í•¨ìˆ˜(ë§¤ê°œë³€ìˆ˜): ë°˜í™˜ê°’ </span>ìœ¼ë¡œ ì„ ì–¸í•œ ê²ƒì€ ë§¤ê°œë³€ìˆ˜ê°€ **ì´ë³€ì„±**ì„ ê°€ì§

- <span style="color:yellowgreen"> í•¨ìˆ˜: (ë§¤ê°œë³€ìˆ˜) => ë°˜í™˜ê°’ </span>ìœ¼ë¡œ ì„ ì–¸í•œ ê²ƒì€ **ë°˜ê³µë³€ì„±**ì„ ê°€ì§


---

## 2.20 í´ë˜ìŠ¤ëŠ” ê°’ì´ë©´ì„œ íƒ€ì…ì´ë‹¤

#### ğŸ—£ï¸ ìë°”ìŠ¤í¬ë¦½íŠ¸ classì™€ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ classì˜ ì°¨ì´

```js
// ìë°”ìŠ¤í¬ë¦½íŠ¸
class Person {
  constructor(name, age, married) {
    this.name = name;
    this.age = age;
    this.married = married;
  }
}
```
```ts
class Person {
  name;
  age;
  married;
  constructor(name: string, age: number, married: boolean) {
    this.name = name;
    this.age = age;
    this.married = married;
  }
}
// (property) Person.name: string
// (property) Person.age: number
// (property) Person.married: boolean
```
- íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ëŠ” `name`, `age`, `married` ê°™ì€ ë©¤ë²„ë¥¼ í´ë˜ìŠ¤ ë‚´ë¶€ì— í•œ ë²ˆ ì ì–´ì•¼ í•¨ (ë©¤ë²„ì˜ íƒ€ì…ì€ ìƒëµ ê°€ëŠ¥, ìƒì„±ì í•¨ìˆ˜ê°€ ì•Œë¼ì„œ ì¶”ë¡ )

```ts
const Person = class {
  name;
  age;
  married;
  constructor(name: string, age: number, married: boolean) {
    this.name = name;
    this.age = age;
    this.married = married;
  }
}
```
- ìœ„ ì½”ë“œì²˜ëŸ¼ í´ë˜ìŠ¤ í‘œí˜„ì‹ë„ ê°€ëŠ¥

```ts
class Person {
  name: string;
  married: boolean;
  constructor(name: string, age: number, married: boolean) {
    this.name = name;
    this.age = age;
  }
}
// Property 'married' has no initializer and is not definitely assigned in the constructor.
// Property 'age' does not exist on type 'Person'.
```
- ë©¤ë²„ëŠ” í•­ìƒ `constructor` ë‚´ë¶€ì™€ ì§ì´ ë§ì•„ì•¼ í•¨

- ìƒì„±ì ë‚´ë¶€ì— í• ë‹¹ ì—†ì´ ë©¤ë²„ë¡œë§Œ ì„ ì–¸í•˜ë©´ ìƒì„±ì ì•ˆì—ì„œ í• ë‹¹ë˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ì—ëŸ¬ ë°œìƒ

- ë©¤ë²„ë¥¼ ì„ ì–¸í•˜ì§€ ì•Šê³  ìƒì„±ìì—ì„œë§Œ ë§Œë“¤ë©´ í•´ë‹¹ ì†ì„±ì´ í´ë˜ìŠ¤ ì•ˆì— ì—†ë‹¤ê³  ì—ëŸ¬ê°€ ë°œìƒ

#### ğŸ—£ï¸ ì¸í„°í˜ì´ìŠ¤ì™€ í•¨ê»˜ implements ì˜ˆì•½ì–´ë¥¼ ì‚¬ìš©í•˜ë©´ í´ë˜ìŠ¤ì˜ ë©¤ë²„ê°€ ì œëŒ€ë¡œ ë“¤ì–´ìˆëŠ”ì§€ ê²€ì‚¬í•  ìˆ˜ ìˆìŒ

```ts
interface Human {
  name: string;
  age: number;
  married: boolean;
  sayName(): void;
}
class Person implements Human {
  name;
  age;
  married;
  constructor(name: string, age: number, married: boolean) {
    this.name = name;
    this.age = age;
    this.married = married;
  }
}
// Class 'Person' incorrectly implements interface 'Human'. Property 'sayName' is missing in type 'Person' but required in type 'Human'.
```


- `Person` í´ë˜ìŠ¤ëŠ” `Human` ì¸í„°í˜ì´ìŠ¤ë¥¼ `implements` í–ˆìœ¼ë‚˜ Human ì¸í„°í˜ì´ìŠ¤ì˜ `sayName` ë©”ì„œë“œë¥¼ êµ¬í˜„í•˜ì§€ ì•Šì•˜ìœ¼ë¯€ë¡œ ì—ëŸ¬ê°€ ë°œìƒí•¨

#### ğŸ—£ï¸ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ëŠ” ìƒì„±ì í•¨ìˆ˜ ë°©ì‹ìœ¼ë¡œ ê°ì²´ë¥¼ ë§Œë“œëŠ” ê²ƒì„ ì§€ì›í•˜ì§€ ì•ŠìŒ

```ts
interface PersonInterface {
  name: string;
  age: number;
  married: boolean;
}
function Person(this: PersonInterface, name: string, age: number, married: boolean) {
  this.name = name;
  this.age = age;
  this.married = married;
}
new Person('zero', 28, false);
// 'new' expression, whose target lacks a construct signature, implicitly has an 'any' type.
```

- ë”°ë¼ì„œ í´ë˜ìŠ¤ê°€ `new`ë¥¼ ë¶™ì—¬ í˜¸ì¶œí•  ìˆ˜ ìˆëŠ” ìœ ì¼í•œ ê°ì²´ì„

#### ğŸ—£ï¸ í´ë˜ìŠ¤ëŠ” ê°’ìœ¼ë¡œ ì“°ì´ë©´ì„œ íƒ€ì…ì´ ë˜ê¸°ë„ í•¨

- í´ë˜ìŠ¤ëŠ” íƒ€ì…ìœ¼ë¡œ ì‚¬ìš©í•  ë•Œ ì¸ìŠ¤í„´ìŠ¤ íƒ€ì…ì´ ë¨

- í´ë˜ìŠ¤ ìì²´ì˜ íƒ€ì…ì´ í•„ìš”í•˜ë©´ `typeof í´ë˜ìŠ¤ì´ë¦„`ìœ¼ë¡œ íƒ€ì´í•‘í•´ì•¼ í•¨ 

```ts
const person1: Person = new Person('zero', 28, false);
const P: typeof Person = Person;
const person2 = new P('nero', 32, true);
```
#### ğŸ—£ï¸ í´ë˜ìŠ¤ ë©¤ë²„ë¡œëŠ” ì˜µì…”ë„ì´ë‚˜ readonly ë¿ë§Œ ì•„ë‹ˆë¼ public, protected, private ìˆ˜ì‹ì–´ê°€ ì¶”ê°€ë¨

```ts
class Parent {
  name?: string;
  readonly age: number;
  protected married: boolean;
  private value: number;
  constructor(name: string, age: number, married: boolean) {
    this.name = name;
    this.age = age;
    this.married = married;
    this.value = 0;
  }
  changeAge(age: number) {
    this.age = age;
  }
}
// Cannot assign to 'age' because it is a read-only property.
class Child extends Parent {
  constructor(name: string, age: number, married: boolean) {
    super(name, age, married);
  }
  sayName() {
    console.log(this.name);
  }
  sayMarried() {
    console.log(this.married);
  }
  sayValue() {
    console.log(this.value);
  }
}
// Property 'value' is private and only accessible within class 'Parent'.
const child = new Child('zero', 28, false);
child.name;
child.married;
// Property 'married' is protected and only accessible within class 'Parent' and its subclasses.
child.value;
// Property 'value' is private and only accessible within class 'Parent'.
```
- `name`ì—ëŠ” ì˜µì…”ë„ ìˆ˜ì‹ì–´ë¥¼, `age`ì—ëŠ” `readonly` ìˆ˜ì‹ì–´ë¥¼ ë¶™ì„

- `age`ê°€ `readonly`ì´ë¯€ë¡œ `changeAge` ë©”ì„œë“œì—ì„œ ì˜¤ë¥˜ ë°œìƒ

- `protected`ë‚˜ `private`ê°€ ì•„ë‹ˆë©´ ì¼ë°˜ì ìœ¼ë¡œ `public`ì„

> **public ì†ì„±** : 
ì„ ì–¸í•œ ìì‹ ì˜ í´ë˜ìŠ¤, ìì† í´ë˜ìŠ¤, new í˜¸ì¶œë¡œ ë§Œë“¤ì–´ë‚¸ ì¸ìŠ¤í„´ìŠ¤ì—ì„œ ì†ì„± ì‚¬ìš© ê°€ëŠ¥. 
ìœ„ ì½”ë“œì—ì„œ nameì†ì„±. ì—¬ëŸ¬ë²ˆ extends í•´ë„ ìì† í´ë˜ìŠ¤ì„

> **proteced ì†ì„±** :
ìì‹ ì˜ í´ë˜ìŠ¤ì™€ ìì† í´ë˜ìŠ¤ì—ì„œëŠ” ì†ì„±ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìœ¼ë‚˜ ì¸ìŠ¤í„´ìŠ¤ì—ì„œëŠ” ì‚¬ìš©í•  ìˆ˜ ì—†ìŒ
ìœ„ ì½”ë“œì—ì„œ married ì†ì„±ì€ child.marriedì—ì„œ ì—ëŸ¬ ë°œìƒ

> **private ì†ì„±** :
ìì‹ ì˜ í´ë˜ìŠ¤ì—ì„œë§Œ ì†ì„±ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŒ.
ìœ„ ì½”ë“œì—ì„œ value ì†ì„±ì€ Child í´ë˜ìŠ¤ë‚˜ child.valueì—ì„œ ì—ëŸ¬ ë°œìƒ

![](https://velog.velcdn.com/images/nemin/post/2182a68d-caea-4ec3-8fd7-b8e68273a6ea/image.png)


#### ğŸ—£ï¸ private field(#)

- ìë°”ìŠ¤í¬ë¦½íŠ¸ì—ëŠ” ìì²´ì ìœ¼ë¡œ í´ë˜ìŠ¤ì˜ `private` ì†ì„±ì„ ë‚˜íƒ€ë‚´ëŠ” `private field(#)` ê¸°ëŠ¥ì´ ìˆìŒ

- ì†ì„± ì•ì— `#`ì„ ë¶™ì—¬ ì„ ì–¸í•¨

- íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì˜ `private`ì„ ì‚¬ìš©í•  ë•Œì™€ #ì„ ì‚¬ìš©í•  ë•Œì˜ ì°¨ì´ì ì„ ì•Œì•„ë³´ì

```ts
class PrivateMember {
  private priv: string = 'priv';
}
class ChildPrivateMember extends PrivateMember {
  private priv: string = 'priv';
}
// Class 'ChildPrivateMember' incorrectly extends base class 'PrivateMember'. Types have separate declarations of a private property 'priv'.
class PrivateField {
  #priv: string = 'priv';
  sayPriv() {
    console.log(this.#priv);
  }
}
class ChildPrivateField extends PrivateField {
  #priv: string = 'priv';
}
```

- ê°€ì¥ í° ì°¨ì´ì ì€ `private` ìˆ˜ì‹ì–´ë¡œ ì„ ì–¸í•œ ì†ì„±ì€ ìì† í´ë˜ìŠ¤ì—ì„œ ê°™ì€ ì´ë¦„ìœ¼ë¡œ ì„ ì–¸í•  ìˆ˜ ì—†ë‹¤ëŠ” ì 

- ìì† í´ë˜ìŠ¤ì—ì„œ `private`ìœ¼ë¡œ ì„ ì–¸í•œ ê²ƒì€ ì—ëŸ¬ ë°œìƒ, `#`ìœ¼ë¡œ ì„ ì–¸í•œ ê²ƒì€ ì—ëŸ¬ê°€ ë°œìƒí•˜ì§€ ì•ŠìŒ

#### ğŸ—£ï¸ implementsí•˜ëŠ” ì¸í„°í˜ì´ìŠ¤ì˜ ì†ì„±ë“¤ì€ ì „ë¶€ publicì´ì–´ì•¼ í•¨


- ì• ì´ˆì— ì¸í„°í˜ì´ìŠ¤ì˜ ì†ì„±ì€ `proteced`ì´ë‚˜ `private`ì´ ë  ìˆ˜ ì—†ìŒ

- `public`ì´ì–´ì•¼ ì—ëŸ¬ê°€ ë°œìƒí•˜ì§€ ì•ŠìŒ

#### ğŸ—£ï¸ ì˜¤ë²„ë¼ì´ë“œ

- ì˜¤ë²„ë¼ì´ë“œ ìˆ˜ì‹ì–´ë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ `noImplecitOverride` ì˜µì…˜ì„ ì²´í¬í•´ì•¼ í•¨

```ts
class Human {
  eat() {
    console.log('ëƒ ëƒ ');
  }
  sleap() {
    console.log('ì¿¨ì¿¨');
  }
}
class Employee extends Human {
  work() {
    console.log('ë™ì°¨');
  }
  override sleap() {
    console.log('ì—ê³ ê³ ');
  }
}
```

- ëª…ì‹œì ìœ¼ë¡œ ì˜¤ë²„ë¼ì´ë“œí•  ë•ŒëŠ” ìœ„ ì½”ë“œì²˜ëŸ¼ ì•ì— `override` ìˆ˜ì‹ì–´ë¥¼ ë¶™ì—¬ì•¼ í•¨

- `override` ìˆ˜ì‹ì–´ë¥¼ ë¶™ì´ë©´ ë¶€ëª¨ í´ë˜ìŠ¤ì˜ ë©”ì„œë“œê°€ ë°”ë€” ë•Œë§ˆë‹¤ í™•ì¸í•  ìˆ˜ ìˆìŒ

- ë˜ ë¶€ëª¨ í´ë˜ìŠ¤ì˜ ë©”ì„œë“œë¥¼ ì‹¤ìˆ˜ë¡œ ë³€ê²½í–ˆê±°ë‚˜ ë©”ì„œë“œë¥¼ ì˜¤ë²„ë¼ì´ë“œí•  ë•Œ ì˜¤íƒ€ë¥¼ ë‚¸ ê²½ìš° ì‰½ê²Œ í™•ì¸í•  ìˆ˜ ìˆìŒ

#### ğŸ—£ï¸ ì˜¤ë²„ë¡œë”©

- í´ë˜ìŠ¤ì˜ ìƒì„±ì í•¨ìˆ˜ì—ë„ ì˜¤ë²„ë¡œë”©ì„ ì ìš©í•  ìˆ˜ ìˆìŒ

```ts
class Person {
  name?: string;
  age?: number;
  married?: boolean;
  constructor();
  constructor(name: string, married: boolean);
  constructor(name: string, age: number, married: boolean);
  constructor(name?: string, age?: boolean | number, married?: boolean) {
    if (name) {
      this.name = name;
    }
    if (typeof age === 'boolean') {
      this.married = age;
    } else {
      this.age = age;
    }
    if (married) {
      this.married = married;
    }
  }
}
const person1 = new Person();
const person2 = new Person('nero', true);
const person3 = new Person('zero', 28, false);
```

- ì¼ë°˜ í•¨ìˆ˜ì™€ ë¹„ìŠ·í•˜ê²Œ íƒ€ì… ì„ ì–¸ì„ ì—¬ëŸ¬ ë²ˆ í•¨

- í•¨ìˆ˜ì˜ êµ¬í˜„ë¶€ëŠ” í•œ ë²ˆë§Œ í•´ì•¼í•˜ê³  ê·¸ êµ¬í˜„ë¶€ì—ì„œ ì—¬ëŸ¬ ë²ˆ ì„ ì–¸í•œ ê²ƒë“¤ì— ëŒ€í•´ ëª¨ë‘ ëŒ€ì‘í•  ìˆ˜ ìˆì–´ì•¼ í•¨

#### ğŸ—£ï¸ í´ë˜ìŠ¤ ì†ì„±ì—ë„ ìµë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜ ì‚¬ìš© ê°€ëŠ¥

```ts
class Signature {
  [propName: string]: string | number | undefined;
  static [propName: string]: boolean;
}

const sig = new Signature();
sig.hello = 'world';
Signature.isGood = true;
```

- `static` ì†ì„±ì—ë„ ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜ê°€ ê°€ëŠ¥í•˜ë©° ì†ì„±ì„ ììœ ë¡­ê²Œ ì¶”ê°€ ê°€ëŠ¥

#### ğŸ—£ï¸ í´ë˜ìŠ¤ë‚˜ ì¸í„°í˜ì´ìŠ¤ì˜ ë©”ì„œë“œì—ì„œëŠ” thisë¥¼ íƒ€ì…ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆìŒ

```ts
class Person {
  age: number;
  married: boolean;
  constructor(age: number, married: boolean) {
    this.age = age;
    this.married = married;
  }
  sayAge() {
    console.log(this.age);
  }
// this: this
  sayMarried(this: Person) {
    console.log(this.married);
  }
// this: Person
  sayCallback(callback: (this: this) => void) {
    callback.call(this);
  }
}
```
- ê¸°ë³¸ì ìœ¼ë¡œ `this`ëŠ” í´ë˜ìŠ¤ ìì‹ ì´ì§€ë§Œ ëª…ì‹œì ìœ¼ë¡œ íƒ€ì´í•‘í•  ìˆ˜ë„ ìˆìŒ

- `sayCallback` ë©”ì„œë“œì—ì„œ ë§¤ê°œë³€ìˆ˜ë¡œ ê°€ì§€ê³ ìˆëŠ” ì½œë°±í•¨ìˆ˜ì˜ `this` íƒ€ì…ì´ Person ì¸ìŠ¤í„´ìŠ¤ê°€ ë¨

- ì½œë°± í•¨ìˆ˜ì—ì„œ `this`ë¥¼ ì‚¬ìš©í•˜ê³  ì‹¶ìœ¼ë©´ `this`ë¥¼ íƒ€ì´í•‘í•´ì•¼ í•˜ê³  ê·¸ thisê°€ í´ë˜ìŠ¤ ìì‹ ì´ë¼ë©´ `this:this`ë¡œ íƒ€ì´í•‘í•˜ë©´ ë¨

#### ğŸ—£ï¸ ì¸í„°í˜ì´ìŠ¤ë¡œ í´ë˜ìŠ¤ ìƒì„±ìë¥¼ íƒ€ì´í•‘í•  ìˆ˜ ìˆìŒ

- ë©”ì„œë“œë¥¼ ì„ ì–¸í•˜ëŠ” ê²ƒê³¼ ë¹„ìŠ·í•˜ê²Œ ì•ì— `new`ì—°ì‚°ìë¥¼ ì¶”ê°€í•¨

```ts
interface PersonConstructor {
  new (name: string, age: number): {
    name: string;
    age: number;
  };
}

class Person {
  name: string;
  age: number;
  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
}

function createPerson(ctor: PersonConstructor, name: string, age: number) {
  return new ctor(name, age);
}

createPerson(Person, 'zero', 28);
```
- ì´ë¥¼ í™œìš©í•´ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì—ì„œë„ ìƒì„±ì í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆì§€ë§Œ í´ë˜ìŠ¤ë¥¼ ë‘ê³  êµ³ì´ ì´ëŸ° ë°©ì‹ìœ¼ë¡œ ì•ˆ í•´ë„ ë¨

### ì¶”ìƒ í´ë˜ìŠ¤ (abstract class)

- ì¶”ìƒ í´ë˜ìŠ¤ë¡œ `implements`ë³´ë‹¤ ë” êµ¬ì²´ì ìœ¼ë¡œ í´ë˜ìŠ¤ì˜ ëª¨ì–‘ì„ ì •ì˜í•  ìˆ˜ ìˆìŒ

```ts
abstract class AbstractPerson {
  name: string;
  age: number;
  married: boolean = false;
  abstract value: number;

  constructor(name: string, age: number, married: boolean) {
    this.name = name;
    this.age = age;
    this.married = married;
  }
  
  sayName() {
    console.log(this.name);
  }
  abstract sayAge(): void;
  abstract sayMarried(): void;
}
class RealPerson extends AbstractPerson {  // error
  sayAge() {
    console.log(this.age);
  }
}
```

- `abstract class`ë¡œ ì„ ì–¸í•¨

- ì†ì„±ê³¼ ë©”ì„œë“œê°€ `abstract`ì¸ ê²½ìš° ì‚´ì œ ê°’ì€ ì—†ê³  íƒ€ì… ì„ ì–¸ë§Œ ë˜ì–´ ìˆìŒ

- `abstract class`ë¡œ ì„ ì–¸í•œ í´ë˜ìŠ¤ë¥¼ ìƒì†í•  ë•Œ ë°˜ë“œì‹œ `abstract` ì†ì„±ì´ë‚˜ ë©”ì„œë“œë¥¼ êµ¬í˜„í•´ì•¼ í•¨

- `implements`ì™€ ë‹¤ë¥´ê²Œ `abstract` í´ë˜ìŠ¤ëŠ” ì‹¤ì œ ìë°”ìŠ¤í¬ë¦½íŠ¸ ì½”ë“œë¡œ ë³€í™˜ë¨

---

## 2.21 enumì€ ìë°”ìŠ¤í¬ë¦½íŠ¸ì—ì„œë„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤

- `enum`ì€ ì—¬ëŸ¬ ìƒìˆ˜ë¥¼ ë‚˜ì—´í•˜ëŠ” ëª©ì ìœ¼ë¡œ ì“°ì„

- ì›ë˜ ìë°”ìŠ¤í¬ë¦½íŠ¸ì—ëŠ” ì—†ëŠ” íƒ€ì…ì´ì§€ë§Œ ìë°”ìŠ¤í¬ë¦½íŠ¸ ê°’ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” íŠ¹ì´í•œ íƒ€ì…ì„

- `enum` ì˜ˆì•½ì–´ë¡œ ì„ ì–¸í•¨

```ts
enum Level {
  NOVICE,
  INTERMEDIATE,
  ADVANCED,
  MASTER,
}
```

- `enum` ì•ˆì— ì¡´ì¬í•˜ëŠ” ì´ë¦„ì„ ë©¤ë²„(member)ë¼ê³  ë¶€ë¦„

#### ğŸ—£ï¸ `enum`ì€ ë©¤ë²„ì˜ ìˆœì„œëŒ€ë¡œ 0ë¶€í„° ìˆ«ìë¥¼ í• ë‹¹í•¨

- 0 ëŒ€ì‹  = ì—°ì‚°ìë¡œ ë‹¤ë¥¸ ìˆ«ìë¥¼ í• ë‹¹í•  ìˆ˜ ìˆìŒ

```ts
enum Level {
  NOVICE = 3,
  INTERMEDIATE, // ì—¬ê¸°ëŠ” 4
  ADVANCED = 7,
  MASTER, // ì—¬ê¸°ëŠ” 8
}
```

- ë‹¤ìŒ ìˆ«ìëŠ” 1ì„ ë”í•œ ê°’ì´ ìë™ìœ¼ë¡œ ë“¤ì–´ê°

- ë¬¸ìì—´ë„ í• ë‹¹ ê°€ëŠ¥í•œë° í•œ ë©¤ë²„ë¥¼ ë¬¸ìì—´ë¡œ í• ë‹¹í•˜ë©´ ë‹¤ìŒ ê°’ë“¤ë„ ì§ì ‘ í• ë‹¹ í•´ì•¼í•¨

#### ğŸ—£ï¸ enumì€ ê°’ìœ¼ë¡œ? íƒ€ì…ìœ¼ë¡œ?

- `enum` íƒ€ì…ì„ ê°’ìœ¼ë¡œ í™œìš© ê°€ëŠ¥

```ts
enum Level {
  NOVICE,
  INTERMEDIATE,
  ADVANCED,
  MASTER,
}
const a = Level.NOVICE; // 0
const b = Level[Level.NOVICE]; // NOVICE
```
- `enum[enumì˜_ë©¤ë²„]`ëŠ” `enum`ì˜ ë©¤ë²„ ì´ë¦„ì„ ê°€ì ¸ì˜¤ëŠ” ë°©ë²•ì„

- `enum`ì€ ê°’ë³´ë‹¤ íƒ€ì…ìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ” ê²½ìš°ê°€ ë” ë§ìŒ

```ts
// ìœ„ ì½”ë“œë‘ ì´ì–´ì§
function whatsYourLevel(level: Level) {
  console.log(Level[level]);
}

const myLevel = Level.ADVANCED;
whatsYourLevel(myLevel); // 'ADVANCED'
```

- `enum`ì„ íƒ€ì…ìœ¼ë¡œ ì‚¬ìš©í•˜ë©´ ë©¤ë²„ì˜ ìœ ë‹ˆì–¸ê³¼ ë¹„ìŠ·í•œ ì—­í• ì„ í•¨

#### ğŸ—£ï¸ ë¸Œëœë“œ ì†ì„±ìœ¼ë¡œ enumì˜ ë©¤ë²„ë¥¼

- ê°™ì€ `enum` ë©¤ë²„ì—¬ì•¼ ì„œë¡œ êµ¬ë¶„ë¨

- ë‹¤ë¥¸ `enum`ì˜ ë©¤ë²„ê¹Œë¦¬ëŠ” êµ¬ë¶„ë˜ì§€ ì•Šì„ ìˆ˜ ìˆìŒ

```ts
enum Money {
  WON,
}
enum Water {
  LITER,
}
interface M {
  type: Money.WON,
}
interface N {
  type: Water.LITER,
}

function moneyOrLiter(param: M | N) {
  if (param.type === Money.WON) {
    param;
  } else {
    param;
  }
}
moneyOrLiter({ type: Money.WON }) // money
moneyOrLiter({ type: Water.LITER }) // money
```

- ìœ„ëŠ” Moneyì™€ Waterë¥¼ êµ¬ë¶„í•˜ëŠ” ì½”ë“œ

- ë‹¤ë§Œ ì˜ë„ì™€ëŠ” ë‹¤ë¥´ê²Œ êµ¬ë¶„ë˜ì§€ ì•Šê³  ëª¨ë‘ Moneyê°€ ë¨

> ê°™ì€ enumì˜ ë©¤ë²„ë¼ë¦¬ ë¹„êµí•´ì•¼ë§Œ ì˜ë¯¸ê°€ ìˆìŒ

#### ğŸ—£ï¸ ìë°”ìŠ¤í¬ë¦½íŠ¸ ì½”ë“œê°€ ìƒì„±ë˜ì§€ ì•Šê²Œ

- `enum`ì€ ì‚¬ìš©í•˜ê³  ìë°”ìŠ¤í¬ë¦½íŠ¸ ì½”ë“œê°€ ìƒì„±ë˜ì§€ ì•Šê²Œ í•˜ë ¤ë©´ `const enum`ì„ ì‚¬ìš©í•˜ë©´ ë¨

```ts
const enum Money {
  WON,
  DOLLAR,
}

Money.WON;
// (enum member) Money.WON = 0
Money[Money.WON];
// A const enum member can only be accessed using a string literal.
```

---

## 2.22 inferë¡œ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì˜ ì¶”ë¡ ì„ ì§ì ‘ í™œìš©í•˜ì

- `infer` ì˜ˆì•½ì–´ëŠ” íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì˜ íƒ€ì… ì¶”ë¡ ì„ ê·¹í•œê¹Œì§€ í™œìš©í•˜ëŠ” ê¸°ëŠ¥ì´ê³ , ì»¨ë””ì…”ë„ íƒ€ì…ê³¼ í•¨ê»˜ ì‚¬ìš©í•¨

- ì¶”ë¡ ì„ ë§¡ê¸°ê³  ì‹¶ì€ ë¶€ë¶„ì„ `infer íƒ€ì…_ë³€ìˆ˜`ë¡œ í‘œì‹œ

```ts
type El<T> = T extends (infer E)[] ? E : never;
type Str = El<string[]>;
// type Str = string
type NumOrBool = El<(number | boolean)[]>;
// type NumOrBool = number | boolean
```

- ì»¨ë””ì…”ë„ íƒ€ì…ì—ì„œ íƒ€ì… ë³€ìˆ˜ëŠ” ì°¸ ë¶€ë¶„ì—ì„œë§Œ ì“¸ ìˆ˜ ìˆìŒ

#### ğŸ—£ï¸ ì„œë¡œ ë‹¤ë¥¸ íƒ€ì… ë³€ìˆ˜ë¥¼ ì—¬ëŸ¬ ê°œ ë™ì‹œ ì‚¬ìš©

```ts
type MyPAndR<T> = T extends (...args: infer P) => infer R ? [P, R] : never;
type PR = MyPAndR<(a: string, b: number) => string>;
// type PR = [[a: number, b: string], string]
```

- ë©”ê²Œë³€ìˆ˜ëŠ” Píƒ€ì… ë³€ìˆ˜ë¡œ, ë°˜í™˜ê°’ì€ Ríƒ€ì… ë³€ìˆ˜ë¡œ ì¶”ë¡ í•¨

#### ğŸ—£ï¸ ê°™ì€ íƒ€ì… ë³€ìˆ˜ë¥¼ ì—¬ëŸ¬ ê³³ì— ì‚¬ìš©

```ts
type Union<T> = T extends { a: infer U, b: infer U } ? U : never;
type Result1 = Union<{ a: 1 | 2, b: 2 | 3 }>;
// type Result1 = 1 | 2 | 3

type Intersection<T> = T extends {
  a: (pa: infer U) => void, 
  b: (pb: infer U) => void
} ? U : never;
type Result2 = Intersection<{ a(pa: 1 | 2): void, b(pb: 2 | 3): void }>;
// type Result2 = 2
```

- ê°™ì€ ì´ë¦„ì˜ íƒ€ì… ë³€ìˆ˜ëŠ” ì„œë¡œ ìœ ë‹ˆì–¸ ë¨

- ë§¤ê°œë³€ìˆ˜ëŠ” ë°˜ê³µë³€ì„±ì„ ê°–ê³  ìˆì–´ ì¸í„°ì„¹ì…˜ ë¨

- ë°˜í™˜ê°’ íƒ€ì…ì„ ê°™ì€ íƒ€ì… ë³€ìˆ˜ë¡œ ì„ ì–¸í•œ ê²½ìš°ëŠ” ê³µë³€ì„±ì„ ê°€ì§€ê³  ìˆì–´ ìœ ë‹ˆì–¸ ë¨

#### ğŸ—£ï¸ ìœ ë‹ˆì–¸ì„ ì¸í„°ì„¹ì…˜ìœ¼ë¡œ ë§Œë“œëŠ” íƒ€ì…ì„ ì‘ì„±

```ts
type UnionToIntersection<U>
  = (U extends any ? (p: U) => void : never) extends (p: infer I) => void
    ? I
    : never;
type Result5 = UnionToIntersection<{ a: number } | { b: string }>;
/*
type Result5 = {
  a: number;
  } & {
  b: string;
}
*/
type Result6 = UnionToIntersection<boolean | true>;
// type Result6 = never
```

---

## 2.23 íƒ€ì…ì„ ì¢í˜€ ì •í™•í•œ íƒ€ì…ì„ ì–»ì–´ë‚´ì

- 2.6ì—ì„œ `typeof`ë¥¼ ì´ìš©í•œ íƒ€ì… ì¢íˆê¸°ë¥¼ ë°°ì›€

```ts
function strOrNum(param: string | number) {
  if (typeof param === 'string') {
    param;
  } else if (typeof param === 'number') {
    param;
  } else {
    param;
  }
}
// (parameter) param: string
// (parameter) param: number
// (parameter) param: never
```

- ì´ë ‡ê²Œ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ê°€ ì½”ë“œë¥¼ íŒŒì•…í•´ì„œ íƒ€ì…ì„ ì¶”ë¡ í•˜ëŠ” ê±¸ **ì œì–´ íë¦„ ë¶„ì„(Control Flow Anaysis)** ë¼ê³  ë¶€ë¦„

- ì œì–´ íë¦„ ë¶„ì„ì€ ì™„ë²½í•˜ì§€ ì•Šë‹¤ëŠ” ê±¸ ì—¼ë‘í•´ë‘ê³  ì‚¬ìš©í•´ì•¼ í•¨

#### ğŸ—£ï¸ nummê³¼ undefined êµ¬ë¶„

```ts
function strOrNullOrUndefined(param: string | null | undefined) {
  if (typeof param === 'undefined') {
    param;
  } else if (param) {
    param;
  } else {
    param;
  }
}
// (parameter) param: undefined
// (parameter) param: string
// (parameter) param: string | null
```

- `else if` ë¬¸ì—ì„œ `string`ì´ ê±¸ëŸ¬ì§€ì§€ ì•Šì•„ ì œëŒ€ë¡œ ëœ ì½”ë“œëŠ” ì•„ë‹˜

- ìë°”ìŠ¤í¬ë¦½íŠ¸ì—ì„œ `typeof null`ì´ `object`ë¼ ê°ì²´ì™€ `typeof` ê²°ê³¼ê°€ ë˜‘ê°™ì•„ì„œ êµ¬ë¶„í•  ìˆ˜ ì—†ìŒ

```ts
function strOrNullOrUndefined(param: string | null | undefined) {
  if (param === undefined) {
    param;
  } else if (param === null) {
    param;
  } else {
    param;
  }
}
// (parameter) param: undefined
// (parameter) param: null
// (parameter) param: string
```
- ìœ„ ì½”ë“œë¡œ `typeof` ì—†ì´ ì‰½ê²Œ êµ¬ë¶„ ê°€ëŠ¥

#### ğŸ—£ï¸ ë°°ì—´ êµ¬ë¶„í•˜ëŠ” ë°©ë²•

```ts
function strOrNumArr(param: string | number[]) {
  if (Array.isArray(param)) {
    param;
  } else {
    param;
  }
}
// (parameter) param: number[]
// (parameter) param: string
```

- `Array.isArray`ë¥¼ ì‚¬ìš©

#### ğŸ—£ï¸ í´ë˜ìŠ¤ êµ¬ë¶„í•˜ëŠ” ë°©ë²•

```ts
class A {}
class B {}
function classAorB (param: A | B) {
  if (param instanceof A) {
    param;
  } else {
    param;
  }
}
// (parameter) param: A
// (parameter) param: B
```

- `instanceof` ì—°ì‚°ìë¥¼ ì‚¬ìš©

- í•¨ìˆ˜ë„ `instanceof Function`ìœ¼ë¡œ êµ¬ë¶„í•  ìˆ˜ ìˆìŒ

#### ğŸ—£ï¸ ë‘ ê°ì²´ë¥¼ êµ¬ë¶„í•˜ëŠ” ë°©ë²•

```ts
interface X {
  width: number;
  height: number;
}
interface Y {
  length: number;
  center: number;
}
function objXorY(param: X | Y) {
  if (param instanceof X) {
    param;
  } else {
    param;
  }
}
// 'X' only refers to a type, but is being used as a value here.
```

- `instanceof`ë¥¼ ì‚¬ìš©í–ˆì§€ë§Œ ì—ëŸ¬ ë°œìƒ

- `ifë¬¸`ì€ ìë°”ìŠ¤í¬ë¦½íŠ¸ì—ì„œ ì‹¤í–‰ë˜ëŠ” ì½”ë“œì¸ë° XëŠ” íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ ì¸í„°í˜ì´ìŠ¤ì´ë¯€ë¡œ ì—ëŸ¬ê°€ ë°œìƒí•¨

> íƒ€ì… ì¢íˆê¸°ëŠ” ìë°”ìŠ¤í¬ë¦½íŠ¸ ë¬¸ë²•ì„ ì‚¬ìš©í•´ì„œ ì§„í–‰í•´ì•¼ í•œë‹¤.
ìë°”ìŠ¤í¬ë¦½íŠ¸ì—ì„œë„ ì‹¤í–‰í•  ìˆ˜ ìˆëŠ” ì½”ë“œì—¬ì•¼ í•˜ê¸° ë–„ë¬¸ì´ë‹¤.

#### ğŸ—£ï¸ Xì™€ Yì˜ ì°¨ì´ì ì— ì£¼ëª©

```ts
function objXorY(param: X | Y) {
  if ('width' in param) {
    param;
  } else {
    param;
  }
}
// (parameter) param: X
// (parameter) param: Y
```

- ìƒì†Œí•  ìˆ˜ ìˆì§€ë§Œ `in` ì—°ì‚°ìë„ ìë°”ìŠ¤í¬ë¦½íŠ¸ì—ì„œ ì‚¬ìš©í•˜ëŠ” ë¬¸ë²•ì„

#### ğŸ—£ï¸ ë¸Œëœë“œ ì†ì„± ì‚¬ìš©

```ts
interface Money {
  __type: 'money';
  amount: number;
  unit: string;
}

interface Liter {
  __type: 'liter';
  amount: number;
  unit: string;
}

function moneyOrLiter(param: Money | Liter) {
  if (param.__type === 'money') {
    param;
  } else {
    param;
  }
}
// (parameter) param: Money
// (parameter) param: Liter
```

- ê³µí†µ ì†ì„±ì´ ìˆìœ¼ë¯€ë¡œ `in` ì—°ì‚°ì ëŒ€ì‹  ë°”ë¡œ ì†ì„±ì— ì ‘ê·¼ í•  ìˆ˜ ìˆìŒ

#### ğŸ—£ï¸ ì§ì ‘ íƒ€ì… ì¢íˆê¸° í•¨ìˆ˜ë¥¼ ë§Œë“¤ê¸°

```ts
function isMoney(param: Money | Liter): param is Money {
  if (param.__type === 'money') {
    return true;
  } else {
    return false;
  }
}
function moneyOrLiter(param: Money | Liter) {
  if (isMoney(param)) {
    param;
  } else {
    param;
  }
}
// (parameter) param: Money
// (parameter) param: Liter
```

- `ifë¬¸`ì—ì„œ ì‚¬ìš©í•˜ëŠ” í•¨ìˆ˜ë¥¼ ë§Œë“¤ë©´ ì •ìƒ ì‘ë™í•˜ì§€ ì•ŠìŒ

- `inMoney` í•¨ìˆ˜ì˜ ë°˜í™˜ê°’ íƒ€ì…ìœ¼ë¡œ `param is Money`íƒ€ì…ì„ í‘œê¸°í•¨

- ìœ„ ê°™ì€ ë°©ì‹ì„ **íƒ€ì… ì„œìˆ  í•¨ìˆ˜(Type Predicate)**ë¼ê³  ë¶€ë¦„

- `is`ë¼ëŠ” íŠ¹ìˆ˜í•œ ì—°ì‚°ìë¥¼ ì‚¬ìš©í•˜ë©´ ë§¤ê°œë³€ìˆ˜ íƒ€ì…ë„ `is`ë’¤ì— ì ì€ íƒ€ì…ìœ¼ë¡œ ì¢í˜€ì§

> ìµœëŒ€í•œ ê¸°ë³¸ì ì¸ íƒ€ì… ì¢íˆê¸°ë¥¼ ë¨¼ì € ì‹œë„í•˜ê³ , ì • ì•ˆ ë  ë•Œ íƒ€ì… ì„œìˆ ì„ ì‚¬ìš©í•˜ëŠ” ê²Œ ì¢‹ìŒ

---

## 2.24 ìê¸° ìì‹ ì„ íƒ€ì…ìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ” ì¬ê·€ íƒ€ì…ì´ ìˆë‹¤

- ì¬ê·€ í•¨ìˆ˜ : ìê¸° ìì‹ ì„ ë‹¤ì‹œ í˜¸ì¶œí•˜ëŠ” í•¨ìˆ˜

- ì¬ê·€ íƒ€ì… : ìê¸° ìì‹ ì„ íƒ€ì…ìœ¼ë¡œ ë‹¤ì‹œ ì‚¬ìš©í•˜ëŠ” íƒ€ì…

#### ğŸ—£ï¸ ì»¨ë””ì…”ë„ íƒ€ì…ì—ë„ ì‚¬ìš© ê°€ëŠ¥
```ts
type ElementType<T> = T extends any[] ? ElementType<T[number]> : T;
```
- ë‹¤ë§Œ íƒ€ì… ì¸ìˆ˜ë¡œ ì‚¬ìš©í•˜ëŠ” ê²ƒì€ ë¶ˆê°€ëŠ¥

```ts
type T = number | string | Record<string, T>;
// Type alias 'T' circularly references itself.
```
- ì´ ê²½ìš° íƒ€ì… ì¸ìˆ˜ë¥¼ ì“°ì§€ ì•ŠëŠ” ë°©ì‹ìœ¼ë¡œ ìˆ˜ì •í•´ì•¼ í•¨

```ts
type T = number | string | { [key: string]: T };
```

#### ğŸ—£ï¸ JSON

- JSON ë°°ì—´ì´ë‚˜  JSON ê°ì²´ ë‚´ë¶€ì—ëŠ” ë‹¤ë¥¸ JSONì´ ë“¤ì–´ ìˆì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì¬ê·€ íƒ€ì…ìœ¼ë¡œ ì„ ì–¸í•´ì•¼ í•¨

```ts
type JSONType =
  | string
  | boolean
  | number
  | null
  | JSONType[]
  | { [key: string]: JSONType };

const a: JSONType = 'string';
const b: JSONType = [1, false, { "hi": "json" }];
const c: JSONType = {
  prop: null,
  arr: [{}],
}
```
- ì¬ê·€ íƒ€ì…ì„ ì‚¬ìš©í•˜ë©´ ë³µì¡í•œ êµ¬ì¡°ë„ ì‰½ê²Œ í‘œí˜„ ê°€ëŠ¥

