# 2.29 ë°°ìš´ ê²ƒì„ ë°”íƒ•ìœ¼ë¡œ íƒ€ì…ì„ ë§Œë“¤ì–´ë³´ì

## íŒë‹¨í•˜ëŠ” íƒ€ì… ë§Œë“¤ê¸°

1ï¸âƒ£ IsNever

Tê°€ neverì¸ì§€ íŒë‹¨í•˜ëŠ” íƒ€ì…ì´ë‹¤.

```ts
type IsNever<T> = [T] extends [never] ? true : false;
```

2ï¸âƒ£ IsAny

Tê°€ anyì¸ì§€ íŒë‹¨í•˜ëŠ” íƒ€ì…ì´ë‹¤.

```ts
type IsAny<T> = string extends number & T ? true : false;
```

3ï¸âƒ£ IsArray

Tê°€ ë°°ì—´ì¸ì§€ íŒë‹¨í•˜ëŠ” íƒ€ì…ì´ë‹¤.

```ts
type IsArray<T> = IsNever<T> extends true
  ? false
  : T extends readonly unknown[]
  ? IsAny<T> extends true
    ? false
    : true
  : false;
```

ë™ì‘ê³¼ì •

1. `IsNever<T> extends true` â†’ Tê°€ neverì´ë©´ false ë°˜í™˜
2. `T extends readonly unknown[]` â†’ Tê°€ ë°°ì—´ì´ë©´ ë‹¤ìŒ ì¡°ê±´ ì‹¤í–‰
3. `IsAny<T> extends true` â†’ Tê°€ anyì´ë©´ false ë¦¬í„´
4. ëª¨ë“  ì¡°ê±´ì„ í†µê³¼í•˜ë©´ true (ì¦‰, TëŠ” ë°°ì—´ì´ë‹¤!)

4ï¸âƒ£ IsTuple

ë°°ì—´ ì¤‘ íŠœí”Œë§Œ íŒë‹¨í•˜ëŠ” íƒ€ì…ì´ë‹¤.

```ts
type IsTuple<T> = IsNever<T> extends true
  ? false
  : T extends readonly unknown[]
  ? number extends T["length"]
    ? false
    : true
  : false;
```

ğŸ’¡ ë™ì‘ê³¼ì •

1. `IsNever<T> extends true ? false` -> IsNever<T>ê°€ trueì¸ì§€ í™•ì¸, Tê°€ neverì´ë©´ false ë°˜í™˜
2. `T extends readonly unknown[]`-> Tê°€ ë°°ì—´ì¸ì§€ í™•ì¸ (T extends readonly unknown[]),ë°°ì—´ì´ ì•„ë‹ˆë©´ false ë°˜í™˜
3. `number extends T["length"] ? false : true : false` ->T["length"]ê°€ numberë¡œ í™•ì¥ë˜ëŠ”ì§€ í™•ì¸,ë°°ì—´ì˜ lengthê°€ numberì´ë©´ ì¼ë°˜ ë°°ì—´ì´ë¯€ë¡œ false, ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ íŠœí”Œì´ë¯€ë¡œ true ë°˜í™˜

5ï¸âƒ£ IsUnion

ìœ ë‹ˆì–¸ì¸ì§€ íŒë‹¨í•˜ëŠ” íƒ€ì…ì´ë‹¤.

```ts
type IsUnion<T> = IsNever<T> extends true
  ? false
  : T extends T
  ? [U] extends [T]
    ? false
    : true
  : false;
```

ğŸ’¡ ë™ì‘ê³¼ì •

1. `(IsNever<T> extends true ? false)` -> Tê°€ neverì¸ì§€ í™•ì¸í•œë‹¤.
2. `T extends T`-> ë¶„ë°°ë²•ì¹™ì„ í™œì„±í™”í•œë‹¤.
3. `[U] extends [T] ? false : true : false` -> Tê°€ ìœ ë‹ˆì–¸ì´ë©´ [U] extends [T]ê°€ falseê°€ ë˜ë©´ì„œ ìœ ë‹ˆì–¸ì„ì„ ì˜ë¯¸í•˜ê³  ìœ ë‹ˆì–¸ì´ ì•„ë‹ˆë¼ë©´ trueê°€ ë˜ë©´ì„œ ë‹¨ì¼ íƒ€ì…ì„ì„ ì˜ë¯¸í•œë‹¤.

## ì§‘í•© ê´€ë ¨ íƒ€ì… ë§Œë“¤ê¸°

1ï¸âƒ£ Omit

íŠ¹ì • ê°ì²´ì—ì„œ ì§€ì •í•œ ì†ì„±ì„ ì œê±°í•˜ëŠ” íƒ€ì…ì´ë‹¤.<br>
ë‚´ì¥ ìœ í‹¸ë¦¬í‹° íƒ€ì…ì´ë‹¤.

```ts
type Diff<A, B> = Omit<A & B, keyof B>;
type R = Diff<
  { name: string; age: number },
  { name: string; married: boolean }
>;

// Rì— ë§ˆìš°ìŠ¤ì˜¤ë²„í•˜ë©´ type R = {age: number}ì´ ë‚˜ì˜¨ë‹¤.
```

ğŸ’¡ ë™ì‘ê³¼ì •

`A & B` -> `name: string, age: number, married: boolean `<br>
`keyof B` -> `name: string, married: boolean`<br>
`Omit` -> `A & B`ì—ì„œ `keyof B`ë¥¼ ì œê±° <br>
`R` - > `age: number`ë§Œ ë‚¨ëŠ”ë‹¤.

2ï¸âƒ£ Diff

ë‘ ê°œì˜ ê°ì²´ë¥¼ ë¹„êµí•˜ì—¬ í•˜ë‚˜ì—ì„œ ë‹¤ë¥¸ í•˜ë‚˜ì˜ ì†ì„±ì„ ì œê±°í•˜ëŠ” íƒ€ì…ì´ë‹¤.<br>
Omitì„ í™œìš©í•œ ìœ í‹¸ë¦¬í‹° íƒ€ì…ì´ë‹¤.

```ts
type SymDiff<A, B> = Omit<A & B, keyof (A | B)>;
type R = SymDiff<
  { name: string; age: number },
  { name: string; married: boolean }
>;

// Rì— ë§ˆìš°ìŠ¤ì˜¤ë²„í•˜ë©´ type R = {age: number, married: boolean}ì´ ë‚˜ì˜¨ë‹¤.
```

ğŸ’¡ ë™ì‘ê³¼ì •

`A & B` -> `{ name: string; age: number; married: boolean }`<br>
`keyof (A | B) `-> `"name" | "age" | "married"`<br>
`Omit<A & B, keyof (A | B)>` -> `{age: number, married: boolean}`ë§Œ ë‚¨ëŠ”ë‹¤.

2ï¸âƒ£-1ï¸âƒ£ ìœ ë‹ˆì–¸ì—ì„œ ëŒ€ì¹­ì°¨ì§‘í•© ì ìš©

```ts
type SymDiffUnion<A, B> = Exclude<A | B, A & B>;
type R = SymDiffUnion<1 | 2 | 3, 2 | 3 | 4>;

// Rì— ë§ˆìš°ìŠ¤ì˜¤ë²„í•˜ë©´ 1|4ê°€ ë‚˜ì˜¨ë‹¤.
```

3ï¸âƒ£ Exclude

ì–´ë–¤ íƒ€ì…(A | B)ì—ì„œ ë‹¤ë¥¸ íƒ€ì…(A & B)ì„ ì œê±°í•˜ëŠ” íƒ€ì…ì´ë‹¤.

```ts
type IsSubset<A, B> = A extends B ? true : false;
type R1 = IsSubset<string, string | number>; // stringì€ string | numberì˜ ë¶€ë¶„ì§‘í•©ì´ë¯€ë¡œ true
type R2 = IsSubset<{ name: string; age: number }>; //{ name: string; age: number }ëŠ” ë³¸ì¸ê³¼ ë™ì¼í•˜ë¯€ë¡œ true
type R3 = IsSubset<symbol, unknown>; // ëª¨ë“  íƒ€ì…ì€ unknownì˜ ì„œë¸Œíƒ€ì…ì´ë¯€ë¡œ true
```

4ï¸âƒ£ Equal

ë‘ íƒ€ì…ì´ ë™ì¼í•œì§€ íŒë‹¨í•˜ëŠ” íƒ€ì…ì´ë‹¤.

```ts
type Equal<A, B> = A extends B ? (B extends A ? true : false) : false;

type R1 = Equal<boolean, true | false>; // trueê°€ ë‚˜ì˜¬ ê²ƒì´ë¼ê³  ì˜ˆìƒí–ˆì§€ë§Œ boolean
type R2 = Equal<never, never>; // trueê°€ ë‚˜ì˜¬ ê²ƒì´ë¼ê³  ì˜ˆìƒí–ˆì§€ë§Œ never
```

ìœ„ì˜ ì˜ˆì œì—ì„œëŠ” ë¶„ë°°ë²•ì¹™ì— ì˜í•´ ì˜ˆìƒì¹˜ëª»í•œ íƒ€ì…ìœ¼ë¡œ ì¶”ë¡ ëœë‹¤. ë¶„ë°°ë²•ì¹™ì„ ë§‰ê³  ì‹¶ë‹¤ë©´..

```ts
type Equal<A, B> = [A] extends [B] ? ([B] extends [A] ? true : false) : false;
```

í•˜ì§€ë§Œ ì´ ì˜ˆì œëŠ” anyì™€ ë‹¤ë¥¸ íƒ€ì…ì„ êµ¬ë³„í•˜ì§€ ëª»í•œë‹¤.anyì™€ ë‹¤ë¥¸ íƒ€ì…ì„ êµ¬ë³„í•˜ê³  ì‹¶ë‹¤ë©´..

```ts
type Equal2<X, Y> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y
  ? 1
  : 2
  ? true
  : false;
```

ğŸ’¡ ë™ì‘ê³¼ì •

`<T>() => T extends X ? 1 : 2` -> ì œë„¤ë¦­ í•¨ìˆ˜ë¥¼ ë§Œë“¤ì–´ Tê°€ Xì— í• ë‹¹ë  ìˆ˜ ìˆìœ¼ë©´ 1, ì•„ë‹ˆë©´ 2ë¥¼ ë°˜í™˜í•œë‹¤.<br>
`extends (<T>() => T extends Y ? 1 : 2) ? true : false` -> Xì™€ Yê°€ ê°™ë‹¤ë©´ ë‘ í•¨ìˆ˜ëŠ” ë™ì¼í•œ íƒ€ì…ì´ ë˜ì–´ true ë°˜í™˜í•˜ê³  ë‹¤ë¥´ë©´ falseë¥¼ ë°˜í™˜í•œë‹¤.

ğŸ’¡ ì˜ˆì œ

```ts
type A = EqualStrict<"hello", "hello">; // true (ê°™ì€ íƒ€ì…)
type B = EqualStrict<"hello", string>; // false ("hello"ëŠ” stringì˜ ë¶€ë¶„ì§‘í•©)
type C = EqualStrict<number, string>; // false (ì™„ì „íˆ ë‹¤ë¥¸ íƒ€ì…)
```

í•˜ì§€ë§Œ ìœ ì˜í•  ì ì´ ìˆë‹¤.

1. anyëŠ” ë‹¤ë¥¸ íƒ€ì…ê³¼ ì˜ êµ¬ë³„í•˜ì§€ë§Œ ì¸í„°ì„¹ì…˜ì„ ì¸ì‹í•˜ì§€ ëª»í•œë‹¤.
2. Equal2<any,known>ì˜ ê²½ìš°ëŠ” extendsë¥¼ falseë¡œ ë§Œë“œëŠ” Tê°€ ì—†ìŒì—ë„ falseê°€ ëœë‹¤.

5ï¸âƒ£ NotEqual

í•´ë‹¹ íƒ€ì…ì´ ì•„ë‹Œì§€ íŒë‹¨í•˜ëŠ” íƒ€ì…ì´ë‹¤.

```ts
type NotEqual<X, Y> = Equal<X, Y> extends true ? false : true;
```

