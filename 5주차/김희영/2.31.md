# 2.31 í•¨ìˆ˜ì— ê¸°ëŠ¥ì„ ì¶”ê°€í•˜ëŠ” ë°ì½”ë ˆì´í„° í•¨ìˆ˜ê°€ ìˆë‹¤.

## ë°ì½”ë ˆì´í„° 

---
- í´ë˜ìŠ¤ì˜ ê¸°ëŠ¥ì„ ì¦ê°•í•˜ëŠ” í•¨ìˆ˜ì´ë‹¤.
- ì—¬ëŸ¬ í•¨ìˆ˜ì—ì„œ ê³µí†µìœ¼ë¡œ ìˆ˜í–‰ë˜ëŠ” ë¶€ë¶„ì„ ë°ì½”ë ˆì´í„°ë¡œ ë§Œë“ ë‹¤.

```ts
class A{
    eat()
    {
        console.log('start'); // ì¤‘ë³µ
        console.log('Eat');
        console.log('end'); // ì¤‘ë³µ
    }
    work(){
        console.log('start'); // ì¤‘ë³µ
        console.log('Work');
        console.log('end'); // ì¤‘ë³µ
    }
}
```
ìœ„ì™€ ê°™ì´ `console.log('start'); console.log('end');`ê°€ ì¤‘ë³µë˜ëŠ” ìƒí™©ì—ì„œ ë°ì½”ë ˆì´í„°ë¥¼ ì‚¬ìš©í•˜ë©´ ì¤‘ë³µì„ ì œê±°í•  ìˆ˜ ìˆë‹¤.
```ts
function startAndEnd<This, Args extends any[],Return>(
    originalMethod: (this:This, ...args: Args)=>Return,
    context: ClassDecoratorContext<This, (this:This,...args:Args)=>Return> // ë°ì½”ë ˆì´í„°ì˜ ì •ë³´ë¥¼ ê°–ê³  ìˆìŒ
    
) {
    function replacementMethod(this: This,... args:Args): Return{
        console.log('start');
        const result = originalMethod.call(this, ...args);
        console.log('end');
        return result;
    }
    return replacementMethod
}

class A{
    @startAndEnd
    eat(){
        console.log('Eat')
    }
    @startAndEnd
    work(){
        console.log('Work')
    }
}

```
## context 

---
### ì •ì˜
- ë°ì½”ë ˆì´í„°ì˜ ì •ë³´ë¥¼ ê°–ê³  ìˆëŠ” ë§¤ê°œë³€ìˆ˜ì´ë‹¤.
### ì¢…ë¥˜
#### 1ï¸âƒ£ ClassDecoratorContext: í´ë˜ìŠ¤ ìì²´ë¥¼ ì¥ì‹í•  ë•Œ
#### 2ï¸âƒ£ ClassMethodDecoratorContext: í´ë˜ìŠ¤ ë©”ì„œë“œë¥¼ ì¥ì‹í•  ë•Œ
#### 3ï¸âƒ£ ClassGetterDecoratorContext: í´ë˜ìŠ¤ getter ë¥¼ ì¥ì‹í•  ë•Œ
#### 4ï¸âƒ£ ClassSetterDecoratorContext: í´ë˜ìŠ¤ setter ë¥¼ ì¥ì‹í•  ë•Œ
#### 5ï¸âƒ£ ClassMemberDecoratorContext: í´ë˜ìŠ¤ ë©¤ë²„ë¥¼ ì¥ì‹í•  ë•Œ
#### 6ï¸âƒ£ ClassAccessorDecoratorContext: í´ë˜ìŠ¤ accessor ë¥¼ ì¥ì‹í•  ë•Œ 
#### 7ï¸âƒ£ ClassFileDecoratorContext: í´ë˜ìŠ¤ í•„ë“œë¥¼ ì¥ì‹í•  ë•Œ
### íƒ€ì…
```ts
type Context = {
    kind: string; 
    name: string | symbol;
    access : {
        get?(): unknown;
        set?(value: unknown):void;
        has?(value: unknown):boolean;
    };
    private?: boolean;
    static?: boolean;
    addInitializer?(initializer: ()=>void): void;
}
```
ì†ì„±
- kind: ë°ì½”ë ˆì´í„°ì˜ ìœ í˜•, ClassDecoratorContextë¼ë©´ class, ClassMethodDecoratorContextë¼ë©´ method
- name: ì¥ì‹ ëŒ€ìƒì˜ ì´ë¦„
- access: has, get, set ë“±ì˜ ì ‘ê·¼ìë¥¼ ëª¨ì•„ë‘” ê°ì²´
- private, static: private ì—¬ë¶€, static ì—¬ë¶€
- addInitializer ë©”ì„œë“œ: ì´ˆê¸°í™”í•  ë•Œ ì‹¤í–‰ëœë‹¤.
## ë§¤ê°œë³€ìˆ˜

---
- ë°ì½”ë ˆì´í„°ë„ í•¨ìˆ˜ì´ë¯€ë¡œ ë§¤ê°œë³€ìˆ˜ë¥¼ ê°€ì§ˆ ìˆ˜ ìˆë‹¤. (ë‹¤ë§Œ, ê³ ì°¨í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ì•¼í•œë‹¤.)
```ts
function startAndEnd(start='start',end ='end'){
    return function RealDecorator<This, Args extends any[], Return>(
        originalMethod: (this: This, ...args:Args) =>Return,
        context: ClassMethodDecoratorContext<This,(this:This, ...args:Args) => Return>){
        function replacementMethod(this: This, ...args:Args): Return{
            console.log(context.name, start);
            const result = originalMethod.call(this, ...args);
            console.log(context.name, end);
            return result;
        }
    return replacementMethod;
}}

class A{
    @startAndEnd()
    eat(){
        console.log('Eat')
    }
    @startAndEnd()
    work(){
        console.log('Work')
    }
    @startAndEnd('ì‹œì‘','ë')
    sleap(){
        console.log('Sleap')
    }
}
```

### ğŸ’¡ ë™ì‘ ê³¼ì •
```ts
function startAndEnd(start='start',end='end'){
    return function RealDecorator<This, Args extends any[], Return>(
        originalMethod: (this: This, ...args:Args) =>Return,
        context: ClassMethodDecoratorContext<This,(this:This, ...args:Args) => Return>){}}
```
â€¢	startAndEnd(start, end) : ë°ì½”ë ˆì´í„°ë¥¼ ì‹¤í–‰í•  ë•Œ ì¸ìë¡œ startì™€ end ë¬¸ìì—´ì„ ë°›ë„ë¡ í•œë‹¤.<br/>
â€¢	RealDecorator() : ë°ì½”ë ˆì´í„° ë‚´ë¶€ í•¨ìˆ˜<br>
â€¢	originalMethod : ì›ë˜ ë©”ì„œë“œ (eat(), work() ë“±)<br>
â€¢	context : ë©”ì„œë“œì— ëŒ€í•œ ì •ë³´ (ì˜ˆ: ë©”ì„œë“œ ì´ë¦„)
```ts
        function replacementMethod(this: This, ...args:Args): Return{
            console.log(context.name, start);
            const result = originalMethod.call(this, ...args);
            console.log(context.name, end);
            return result;
        }
```
â€¢	replacementMethod() : ì›ë˜ í•¨ìˆ˜ ëŒ€ì‹  ì‹¤í–‰ë  í•¨ìˆ˜<br>
â€¢	ì‹¤í–‰ë˜ë©´ ì•ë’¤ì— start ì™€ end ë¥¼ ì¶œë ¥í•˜ê³  ì›ë˜ í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•œ í›„ ê²°ê³¼ë¥¼ ë°˜í™˜
```ts
    return replacementMethod;
```
â€¢	ì›ë˜ í•¨ìˆ˜ (eat(), work())ë¥¼ ë°ì½”ë ˆì´í„°ê°€ ê°ì‹¼ ìƒˆë¡œìš´ í•¨ìˆ˜ë¡œ êµì²´

---

```ts
function startAndEnd(start = 'start', end = 'end') {
  ...
}
function log<Input extends new (...args: any[]) => any>(
  value: Input,
  context: ClassDecoratorContext
) {
  if (context.kind === "class") {
    return class extends value {
      constructor(...args: any[]) {
        super(args);
      }
      log(msg: string): void {
        console.log(msg);
      }
    };
  }
  return value;
}
function bound(originalMethod: unknown, context: ClassMethodDecoratorContext<any>) {
  const methodName = context.name;
  if (context.kind === 'method') {
    context.addInitializer(function () {
      this[methodName] = this[methodName].bind(this);
    });
  }
}
@log
export class C {
    @bound
    @startAndEnd()
    eat() {
        console.log('Eat');
    }

    @bound @startAndEnd() work() {
        console.log('Work');
    }

    @startAndEnd('ì‹œì‘', 'ë')
    sleap() {
        console.log('Sleap');
    }
}
- new C()ë¥¼ í•  ë•Œ this.eat = this.eat.bind(this)ê°€ í˜¸ì¶œëœë‹¤.
```
- ë°ì½”ë ˆì´í„°ë¥¼ ì—¬ëŸ¬ ê°œ ë¶™ì¼ ìˆ˜ ìˆë‹¤.(ì¤„ë°”ê¿ˆì€ ì„ íƒ) <br>
```ts
  @bound
  @startAndEnd()
  eat() {
  console.log('Eat');
  }`
```
- í´ë˜ìŠ¤ ë°ì½”ë ˆì´í„°ì˜ ê²½ìš° exportë‚˜ export default ì•ì´ë‚˜ ë’¤ì— ë°ì½”ë ˆì´í„°ë¥¼ ë¶™ì¼ ìˆ˜ ìˆë‹¤. (ë‹¤ë§Œ ì•ê³¼ ë’¤ì— ë™ì‹œì— ë¶™ì¼ ìˆ˜ëŠ” ì—†ë‹¤)
```ts
@Log export class C { //export ì•

export @Log class C { //export ë’¤

@Log
export class C { // ì¤„ë°”ê¿ˆ & export ì•

```
