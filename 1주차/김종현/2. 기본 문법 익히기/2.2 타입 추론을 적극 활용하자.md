
#### **1️⃣ 타입 추론 (Type Inference)**

- TypeScript는 **변수 선언 시 타입을 자동으로 추론**한다.
	- 특히, **함수의 반환 값은 별도의 타입 선언 없이 자동으로 추론 됨**.

		```
					
		function plus(x: number, y: number): number {
			return x + y;	
		}
		 
		const result = plus(1,2); //number 형으로 추론된다.
		```

#### **2️⃣ 함수의 매개변수 타입 명시 필요**

- **함수의 매개변수는 반드시 타입을 명시**해야 하며, **생략하면 `any` 타입이 됨.**
	```
	function plus(x: number, y: number): number {
			return x + y;	
		}
	```
	- 타입을 지정하지 않으면 묵시적으로 any 타입을 가지게 된다.
	![[Pasted image 20250209145338.png]]


#### **3️⃣ TypeScript의 타입 추론 원칙**

- TypeScript가 **정확하게 타입을 추론할 때는 추가적인 타입 표기가 불필요**하다.
	- 하지만 **잘못된 타입을 추론할 경우 명시적으로 타입을 선언하는 것이 중요**하다.


#### **4️⃣ 리터럴 타입 vs 일반 타입**

- `const` 선언의 경우, 값 자체를 타입으로 추론한다.
- **타입스크립트가 타입을 제대로 추론하면 그대로 사용하고, 틀리게 추론할 때만 올바른 타입을 표기한다.**
	
	ex) const(상수) 변수 선언 & 리터럴 타입 => 선언한 것 자체가 자료형으로 인식됨
		- 상수로 선언한 변수는 값 할당 후 다른 값을 대입할 수 없으므로 타입을 **좁게** 추론한다.
	- const str = 'hello'; // string 타입이 아닌 "hello"가 타입으로 지정됨
	- const num = 123; // number 타입이 아닌 123이 타입으로 지정됨
	- const bool = false; // boolean 타입이 아닌 false 가 타입으로 지정됨
	- const n = null; 
	- const u = undefined;
	- const sym = Symbol('sym');
	- const big = 100000000n;
	- const obj = {hello: 'world'};


#### 5️⃣**const와 let의 타입 추론 차이**
| 선언 방식     | 타입 추론 방식 | 설명                                  |
| --------- | -------- | ----------------------------------- |
| **const** | 좁은 타입 추론 | 값이 변경되지 않으므로 값 자체를 타입으로 인식 (리터럴 타입) |
| **let**   | 넓은 타입 추론 | 값이 변경될 가능성이 있으므로 일반적인 타입으로 추론       |
	1. **리터럴 타입: 타입을 표기할 때 정확히 특정 값으로 표기할 수 있다.**
	2. **타입을 표기할 때 더 넓은 타입으로 표기해도 괜찮다.**
	ex1)
```
	const str1 : 'hello' = 'hello';
```
- str1 은 값으로 정확히 'hello' 만을 허용한다. => 리터럴 타입
	- 타입 'hello'는 문자열 'hello' 만 가능한 리터럴 타입이다. 따라서 문자열 'hello' 이외에 다른 값은 허용되지 않는다.
		```
		const str2 : string = 'hello';
		```
- str2 는 어떤 문자열이든 가질 수 있는 string 타입이다. => 일반적인 string 타입		- 타입스크립트는 'hello'라는 값을 문자열 타입으로 해석하므로, str2 이후에 다른 문자열 값으로 변경할 수 있다.
	```
		const str3 : {} = 'hello'; 
	```
- **빈 객체 타입**: {} 타입은 null, undefined를 제외한 모든 값을 허용한다.
	- {} 의 특징:
		- {}는 "어떠한 속성도 포함하지 않은 객체"를 의미하지만, 타입스크립트에서는 이 타입이 null, undefined를 제외한 거의 모든 값을 수용하는 타입으로 인식한다.
		- 이 경우 str3 에 'hello'타입을 지정했더라도, 타입 선언이 모호하다. (정확히 문자열 'hello' 가 타입이 될지, string 타입이 될지 알 수 없다.)
	- 본문의 내용 이해하기
		- 셋 중에 가장 정확한 타입은 'hello' 이다.
		- 2.1 절의 예시에서 타입이 더 부정확하다. 타입스크립트가 추론한 타입과 다르기 때문이다.
			- 문자열 자료형 string에 해당하는 어느 값이든 올바른 타입으로 인정하기 때문이다.
			- 이렇게 **좁은 추론**(보다 정확한 추론)을 타입스크립트가 제공하는 경우, 임의의 문자열 string 형 타입보다 정확한 문자열 'hello'을 타입으로 추론하는게 더 정확하다.
			- 따라서 타입스크립트가 좁은 추론을 정확하게 지정하고 있을 때 그대로 사용하는 것이 낫고, 잘못 추론한다면 그 때 타입을 표기한다는 원칙을 세우는 것이다.
			
	ex2) let 으로 선언한 변수의 타입
	- let str = 'hello'; // string 타입
	- let num = 123; // number 타입
	- let bool = false; // boolean 타입
	- let n = null;  // any 타입
	- let u = undefined; // any 타입
	- let sym = Symbol('sym'); //symbol 타입
	- let big = 100000000n; // bigint 타입
	- let obj = {hello: 'world'}; // string 타입
		
	1. let을 사용하면 const와는 전혀 다르게 타입을 추론한다.
		- let으로 선언한 변수는 다른 값을 대입할 수 있기에 타입을 **넓게** 추론한다.
	2. **null, undefined 는 any 형으로 추론한다.**
	3. symbol 형
		- const의 예제에선 type of sym 이라는 고유한 symbol로 타입을 추론한다.
			- 이런 타입을 unique symbol이라고 함				- 이런 unique symbol 끼리는 서로 비교할 수 없다.
				- 타입스크립트는 2 개의 unique symbol 의 비교를 금지하고 있기 때문
		- 단, 다음의 경우는 비교 가능하다.
			- unique symbol 과 일반 symbol
			-  두 개의 일반 symbol
	4. {변수: 타입}의 경우
		- const와 let모두 변수의 타입을 타입형으로 추론한다.
		- const나 let일 때 모두 객체의 속성을 변경할 수 있기 때문

#### **6️⃣ 타입스크립트의 타입 추론 오류 해결 방법 (TypeScript Playground)**

- 타입스크립트는 엄격한 타입 검사를 수행하지만, 필요에 따라 특정 오류를 무시할 수 있다.
	- //@ts-ignore: 자바스크립트에서 발생하지 않는 오류는 타입스크립트에서 전부 무시한다.  코드가 잘못되었든 아니든 무조건 에러를 무시한다.  처음부터 올바른 타입을 지정하는 타입스크립트를 작성하는데 더 신경써야하므로 임시방편으로 여기는 게 좋다.
	- //@ts-espect-error: 에러가 나는 코드라는 것을 인식하고 무시한다.
	- ⚠️ **하지만 이런 주석은 임시방편이며, 타입을 명확하게 선언하는 것이 바람직함.**


### **📌 결론**

- **TypeScript는 타입을 자동으로 추론하지만, 함수의 매개변수는 명시적으로 타입을 선언해야 함**.
- **리터럴 타입과 일반 타입의 차이를 이해하면, 더 정확한 타입 선언이 가능**.
- **타입스크립트의 엄격한 타입 추론을 피하려면 타입을 명시적으로 선언하거나, `@ts-ignore` 같은 주석을 사용할 수 있지만, 이는 최후의 수단으로 고려해야 함**
