# 2.25 ì •êµí•œ ë¬¸ìì—´ ì¡°ì‘ì„ ìœ„í•´ í…œí”Œë¦¿ ë¦¬í„°ëŸ´ íƒ€ì…ì„ ì‚¬ìš©í•˜ì

ìë°”ìŠ¤í¬ë¦½íŠ¸ì˜ í…œí”Œë¦¿ ë¦¬í„°ëŸ´ : ``(ë°±í‹±), ${}(ë³´ê°„)

`ì´ë¦„ì€ ${name}ì…ë‹ˆë‹¤.`

íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì˜ í…œí”Œë¦¿ ë¦¬í„°ëŸ´

- í…œí”Œë¦¿ íƒ€ì…ì„ ì‚¬ìš©í•˜ë©´ ì •í•´ì§„ ë¬¸ìì—´ë§Œ ë³€ìˆ˜ì— ëŒ€ì…í•  ìˆ˜ ìˆë‹¤.
- â€œtemplate â€œ + â€œThis is literalâ€ ì´ì™¸ì˜ ê°’ì„ ê°•ì œì ìœ¼ë¡œ ì œí•œí•˜ëŠ” ê²ƒì´ë‹¤.

```ts
type Literal = "This is literal";
type Template = `template ${Literal}`;
const correct: Template = `template This is literal`; //â­•ï¸
const wrong: Template = "template Something else"; // âŒ ì˜¤ë¥˜ ë°œìƒ

console.log(correct); // -> template This is literal
```

## íƒ€ì…ì„ ë„“í˜€ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

`type Template`ì€ "This is literal â€œ ë’¤ì— ì–´ë–¤ ë¬¸ìì—´ì´ë“  ì˜¬ ìˆ˜ ìˆëŠ” ë¬¸ìì—´ íƒ€ì…

```ts
type Template = `This is literal ${string}`;
let str: Template = `This is literal `; // â­•ï¸
str = "This is literal hello"; // â­•ï¸
str = "This is literal 123"; // â­•ï¸
str = "This is literal"; // âŒ
```

```ts
type City = "seoul" | "suwon" | "busan";
type Vehicle = "car" | "bike" | "walk";
type ID = `${City}ê¹Œì§€ ${Vehicle}ë¥¼ ì´ìš©í•´ì„œ ê°ˆ ê²ƒì…ë‹ˆë‹¤`;
const id: ID = "seoulê¹Œì§€ bikeë¥¼ ì´ìš©í•´ì„œ ê°ˆ ê²ƒì…ë‹ˆë‹¤"; // â­•ï¸
```

Cityì—ëŠ” seoul, suwon, busanì´ ì˜¬ ìˆ˜ ìˆê³  vehicleì—ëŠ” car, bike, walkê°€ ì˜¬ ìˆ˜ ìˆë‹¤.

## ì œë„¤ë¦­ ë° inferë¥¼ í•¨ê»˜ ì‚¬ìš©í•˜ë©´ ë” ê°•ë ¥í•˜ë‹¤.

xxtestxxì—ì„œ x ì§€ìš°ê¸°

```ts
type RemoveX<Str> = Str extends `x${infer Rest}`
  ? RemoveX<Rest>
  : Str extends `${infer Rest}x`
  ? RemoveX<Rest>
  : Str;
type Removed = RemoveX<"xxtestxx">;
```

> ğŸ“ infer
>
> `infer ë³€ìˆ˜ëª…`ìœ¼ë¡œ ì¡°ê±´ë¶€ íƒ€ì…ì—ì„œ íŠ¹ì • ë¶€ë¶„ì„ ì¶”ì¶œí•  ë•Œ ì‚¬ìš©í•œë‹¤.
>
> ```ts
> type RemoveX<Str> = Str extends `x${infer Rest}` ? Rest : never;
> type Result = RemoveX<"xxtestxx">;
> ```
>
> 1ï¸âƒ£ `x${infer Rest}`ëŠ” xxtestxxì—ì„œ ì²«ë²ˆì§¸ ìë¦¬ê°€ xë©´ ë‚˜ë¨¸ì§€ xtestxxë¥¼ ë°˜í™˜í•œë‹¤.<br>
> 2ï¸âƒ£ ê³ ë¡œ, Rest = 'xtestxx'ê°€ ë˜ë¯€ë¡œ ìµœì¢…ì ìœ¼ë¡œ RemoveX<'xxtestxx'>ëŠ” 'xtestxx'ê°€ ëœë‹¤.

ë™ì‘ê³¼ì •

```ts
type RemoveX<Str> = Str extends `x${infer Rest}`
  ? RemoveX<Rest>
  : Str extends `${infer Rest}x`
  ? RemoveX<Rest>
  : Str;
type Removed = RemoveX<"xxtestxx">;
```

1ï¸âƒ£ Str extends `x${infer Rest}` ? RemoveX<Rest> -> 'xxtestxx' ì•ì— 'x'ê°€ ìˆìœ¼ë¯€ë¡œ Rest = 'xtestxx'ê°€ ë˜ê³ , ë‹¤ì‹œ RemoveX<'xtestxx'>ë¥¼ í˜¸ì¶œí•œë‹¤.

2ï¸âƒ£ Str extends `x${infer Rest}` ? RemoveX<Rest> -> 'xtestxx' â†’ ì•ì— 'x'ê°€ ìˆìœ¼ë¯€ë¡œ Rest = 'testxx'ì´ê³ , ë‹¤ì‹œ RemoveX<'testxx'>ë¥¼ í˜¸ì¶œí•œë‹¤.

3ï¸âƒ£ Str extends `x${infer Rest}` ? RemoveX<Rest>ì—ì„œ ë”ì´ìƒ ì§€ìš¸ xê°€ ì—†ìœ¼ë¯€ë¡œ Str extends `${infer Rest}x`ë¡œ ë„˜ì–´ê°„ë‹¤.
'testxx' â†’ ë’¤ì— 'x'ê°€ ìˆìœ¼ë¯€ë¡œ Rest = 'testx'ì´ê³ , ë‹¤ì‹œ RemoveX<'testx'>ë¥¼ í˜¸ì¶œí•œë‹¤.

4ï¸âƒ£ 'testx' â†’ ë’¤ì— 'x'ê°€ ìˆìœ¼ë¯€ë¡œ Rest = 'test'ì´ê³ , ë‹¤ì‹œ RemoveX<'test'>ë¥¼ í˜¸ì¶œí•œ5ï¸ë‹¤.

5ï¸âƒ£ 'test' â†’ ë” ì´ìƒ 'x'ê°€ ì—†ìœ¼ë¯€ë¡œ testê°€ ë°˜í™˜ëœë‹¤.

# 2.26 ì¶”ê°€ì ì¸ íƒ€ì… ê²€ì‚¬ì—ëŠ” satisfies ì—°ì‚°ìë¥¼ ì‚¬ìš©í•œë‹¤.

```ts
const universe = {
    sun: 'star',
    sriius: 'star',
    earth: {type: "planet", parent: "sun"},
}

//ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜ ì‚¬ìš© -> {type: string, parent: string} | string} ë‘˜ ë‹¤ ë§Œì¡±í•˜ë¯€ë¡œ {type: string, parent: string} | string}ë¡œ íƒ€ì…ì´ ì¶”ë¡ ëœë‹¤.
const universe: {[key in 'sun' | 'sirius' | 'earth']: {type: string, parent: string} | string} = {
    sun:'star',
    sriius:'star',
    earth: {type: 'planet', parent: 'sun'}
}

//satisfies ì‚¬ìš© -> satisfiesì— ì ì€ íƒ€ì…ìœ¼ë¡œ ë‹¤ì‹œ í•œë²ˆ ê²€ì‚¬í•œë‹¤.
const universe = {
    sun: 'star',
    sriius: 'star',
    earth: {type: "planet", parent: "sun"},
}
const universe = {
    sun: 'star',
    sriius: 'star',
    earth: {type: "planet", parent"sun"}, {
        satisfies {
            [key in 'sun' | 'sirius' | 'earth']: {type: string, parent: string} | string
        }
    }
}
```

# 2.27 íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ëŠ” ê±´ë§ì¦ì´ ì‹¬í•˜ë‹¤.

```ts
try {
} catch (error) {
  if (error as Error) {
    error.message; // 'error' is of type 'unknown'
  }
}
```

â“ erroríƒ€ì…ì„ Errorë¡œ ê°•ì œí–ˆëŠ”ë° ì™œ íƒ€ì…ì´ 'unknown' ìœ¼ë¡œ ëœ°ê¹Œ? <br>
âœ… ì¡°ê±´ë¬¸ì˜ ì°¸, ê±°ì§“ì„ íŒë‹¨í•  ë•Œë§Œ ì£¼ì¥í•œ íƒ€ì…ì´ ì‚¬ìš©ë˜ê¸° ë•Œë¬¸ì— ì¡°ê±´ë¬¸ì„ ë‚˜ì˜¤ë©´ íƒ€ì…ì´ ë‹¤ì‹œ unknownì´ ëœë‹¤.

â“ í•œë²ˆ ì£¼ì¥í•œ íƒ€ì…ì„ ê³„ì† ìœ ì§€í•˜ê³  ì‹¶ë‹¤ë©´?
âœ… 1. ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•œë‹¤.

```ts
try {
} catch (error) {
  const err = error as Error;
  if (err) {
    error.message;
  }
}
```

âœ… 2.instanceofë¥¼ ì‚¬ìš©í•œë‹¤.

```ts
try {
} catch (error) {
  if (error instanceof Error) {
    error.message;
  }
}
```

# 2.28 ì›ì‹œ ìë£Œí˜•ì—ë„ ë¸Œëœë”© ê¸°ë²•ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

ë¸Œëœë”© ê¸°ë²•ì„ ì‚¬ìš©í•˜ë©´ string, number ê°™ì´ ì›ì‹œ ìë£Œí˜• íƒ€ì…ì„ ë” ì„¸ë°€í•˜ê²Œ êµ¬ë¶„í•  ìˆ˜ ìˆë‹¤.

```ts
const kmToMile = (km: number) => {
  return km * 0.62;
};
const mile = kmToMile(3);
console.log(mile); // -> 1.8599999999999999
```

```ts
type Brand<T, B> = T & { _brand: B };
type KM = Brand<number, "km">;
type Mile = Brand<number, "mile">;

const kmToMile = (km: number) => {
  return (km * 0.62) as Mile;
};

const km = 3 as Mile;
const mile = kmToMile(km); // const mileì˜ íƒ€ì…ì€ Mile
const mile2 = 5 as Mile;
kmToMile(mile2); // âŒ kmToMileì—ëŠ” KM íƒ€ì…ë§Œ ì™€ì•¼í•˜ë¯€ë¡œ Mileíƒ€ì…ì€ ë„£ì„ ìˆ˜ ì—†ë‹¤.
```

`type Brand<T,B> = T & {_brand: B};` : TëŠ” ì›ë˜ ìë£Œí˜•(T), BëŠ” ìƒˆë¡œ ë§Œë“¤ ìë£Œí˜•({\_brand: B})<br>
`type KM = Brand<number,'km'>;` : Tì—ëŠ” numberê°€ ë“¤ì–´ê°€ê³  Bì—ëŠ” kmì´ ë“¤ì–´ê°„ë‹¤.

# 2.29 ë°°ìš´ ê²ƒì„ ë°”íƒ•ìœ¼ë¡œ íƒ€ì…ì„ ë§Œë“¤ì–´ë³´ì

## íŒë‹¨í•˜ëŠ” íƒ€ì… ë§Œë“¤ê¸°

1ï¸âƒ£ IsNever

neverì¸ì§€ íŒë‹¨í•˜ëŠ” íƒ€ì…ì´ë‹¤.

```ts
type IsNever<T> = [T] extends [never] ? true : false;
```

2ï¸âƒ£ IsAny

anyì¸ì§€ íŒë‹¨í•˜ëŠ” íƒ€ì…ì´ë‹¤.

```ts
type IsAny<T> = string extends number & T ? true : false;
```

3ï¸âƒ£ IsArray

ë°°ì—´ì¸ì§€ íŒë‹¨í•˜ëŠ” íƒ€ì…ì´ë‹¤.

```ts
type IsArray<T> = IsNever<T> extends true
  ? false
  : T extends readonly unknown[]
  ? IsAny<T> extends true
    ? false
    : true
  : false;
```

ë™ì‘ê³¼ì •

1. `IsNever<T> extends true` â†’ Tê°€ neverì´ë©´ false ë°˜í™˜
2. `T extends readonly unknown[]` â†’ Tê°€ ë°°ì—´ì´ë©´ ë‹¤ìŒ ì¡°ê±´ ì‹¤í–‰
3. `IsAny<T> extends true` â†’ Tê°€ anyì´ë©´ false ë¦¬í„´
4. ëª¨ë“  ì¡°ê±´ì„ í†µê³¼í•˜ë©´ true (ì¦‰, TëŠ” ë°°ì—´ì´ë‹¤!)

4ï¸âƒ£ IsTuple

ë°°ì—´ ì¤‘ íŠœí”Œë§Œ íŒë‹¨í•˜ëŠ” íƒ€ì…ì´ë‹¤.

```ts
type IsTuple<T> = IsNever<T> extends true
  ? false
  : T extends readonly unknown[]
  ? number extends T["length"]
    ? false
    : true
  : false;
```

ğŸ’¡ ë™ì‘ê³¼ì •

1. `IsNever<T> extends true ? false` -> IsNever<T>ê°€ trueì¸ì§€ í™•ì¸, Tê°€ neverì´ë©´ false ë°˜í™˜
2. `T extends readonly unknown[]`-> Tê°€ ë°°ì—´ì¸ì§€ í™•ì¸ (T extends readonly unknown[]),ë°°ì—´ì´ ì•„ë‹ˆë©´ false ë°˜í™˜
3. `number extends T["length"] ? false : true : false` ->T["length"]ê°€ numberë¡œ í™•ì¥ë˜ëŠ”ì§€ í™•ì¸,ë°°ì—´ì˜ lengthê°€ numberì´ë©´ ì¼ë°˜ ë°°ì—´ì´ë¯€ë¡œ false, ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ íŠœí”Œì´ë¯€ë¡œ true ë°˜í™˜

5ï¸âƒ£ IsUnion

ìœ ë‹ˆì–¸ì¸ì§€ íŒë‹¨í•˜ëŠ” íƒ€ì…ì´ë‹¤.

```ts
type IsUnion<T> = IsNever<T> extends true
  ? false
  : T extends T
  ? [U] extends [T]
    ? false
    : true
  : false;
```

ğŸ’¡ ë™ì‘ê³¼ì •

1. `(IsNever<T> extends true ? false)` -> Tê°€ neverì¸ì§€ í™•ì¸í•œë‹¤.
2. `T extends T`-> ë¶„ë°°ë²•ì¹™ì„ í™œì„±í™”í•œë‹¤.
3. `[U] extends [T] ? false : true : false` -> Tê°€ ìœ ë‹ˆì–¸ì´ë©´ [U] extends [T]ê°€ falseê°€ ë˜ë©´ ìœ ë‹ˆì–¸ì„ì„ ì˜ë¯¸í•˜ê³  ìœ ë‹ˆì–¸ì´ ì•„ë‹ˆë¼ë©´ trueê°€ ë˜ë©´ì„œ ë‹¨ì¼ íƒ€ì…ì„ì„ ì˜ë¯¸í•œë‹¤.

## ì§‘í•© ê´€ë ¨ íƒ€ì… ë§Œë“¤ê¸°

1ï¸âƒ£ Omit

íŠ¹ì • ê°ì²´ì—ì„œ ì§€ì •í•œ ì†ì„±ì„ ì œê±°í•˜ëŠ” íƒ€ì…ì´ë‹¤.<br>
ë‚´ì¥ ìœ í‹¸ë¦¬í‹° íƒ€ì…ì´ë‹¤.

```ts
type Diff<A, B> = Omit<A & B, keyof B>;
type R = Diff<
  { name: string; age: number },
  { name: string; married: boolean }
>;

// Rì— ë§ˆìš°ìŠ¤ì˜¤ë²„í•˜ë©´ type R = {age: number}ì´ ë‚˜ì˜¨ë‹¤.
```

ğŸ’¡ ë™ì‘ê³¼ì •

`A & B` -> `name: string, age: number, married: boolean `<br>
`keyof B` -> `name: string, married: boolean`<br>
`Omit` -> `A & B`ì—ì„œ `keyof B`ë¥¼ ì œê±° <br>
`R` - > `age: number`ë§Œ ë‚¨ëŠ”ë‹¤.

2ï¸âƒ£ Diff

ë‘ ê°œì˜ ê°ì²´ë¥¼ ë¹„êµí•˜ì—¬ í•˜ë‚˜ì—ì„œ ë‹¤ë¥¸ í•˜ë‚˜ì˜ ì†ì„±ì„ ì œê±°í•˜ëŠ” íƒ€ì…ì´ë‹¤.<br>
Omitì„ í™œìš©í•œ ìœ í‹¸ë¦¬í‹° íƒ€ì…ì´ë‹¤.

```ts
type SymDiff<A, B> = Omit<A & B, keyof (A | B)>;
type R = SymDiff<
  { name: string; age: number },
  { name: string; married: boolean }
>;

// Rì— ë§ˆìš°ìŠ¤ì˜¤ë²„í•˜ë©´ type R = {age: number, married: boolean}ì´ ë‚˜ì˜¨ë‹¤.
```

ğŸ’¡ ë™ì‘ê³¼ì •

`A & B` -> `{ name: string; age: number; married: boolean }`<br>
`keyof (A | B) `-> `"name" | "age" | "married"`<br>
`Omit<A & B, keyof (A | B)>` -> `{age: number, married: boolean}`ë§Œ ë‚¨ëŠ”ë‹¤.

2ï¸âƒ£-1ï¸âƒ£ ìœ ë‹ˆì–¸ì—ì„œ ëŒ€ì¹­ì°¨ì§‘í•© ì ìš©

```ts
type SymDiffUnion<A, B> = Exclude<A | B, A & B>;
type R = SymDiffUnion<1 | 2 | 3, 2 | 3 | 4>;

// Rì— ë§ˆìš°ìŠ¤ì˜¤ë²„í•˜ë©´ 1|4ê°€ ë‚˜ì˜¨ë‹¤.
```

3ï¸âƒ£ Exclude

ì–´ë–¤ íƒ€ì…(A | B)ì—ì„œ ë‹¤ë¥¸ íƒ€ì…(A & B)ì„ ì œê±°í•˜ëŠ” íƒ€ì…ì´ë‹¤.

```ts
type IsSubset<A, B> = A extends B ? true : false;
type R1 = IsSubset<string, string | number>; // stringì€ string | numberì˜ ë¶€ë¶„ì§‘í•©ì´ë¯€ë¡œ true
type R2 = IsSubset<{ name: string; age: number }>; //{ name: string; age: number }ëŠ” ë³¸ì¸ê³¼ ë™ì¼í•˜ë¯€ë¡œ true
type R3 = IsSubset<symbol, unknown>; // ëª¨ë“  íƒ€ì…ì€ unknownì˜ ì„œë¸Œíƒ€ì…ì´ë¯€ë¡œ true
```

4ï¸âƒ£ Equal

ë‘ íƒ€ì…ì´ ë™ì¼í•œì§€ íŒë‹¨í•˜ëŠ” íƒ€ì…ì´ë‹¤.

```ts
type Equal<A, B> = A extends B ? (B extends A ? true : false) : false;

type R1 = Equal<boolean, true | false>; // trueê°€ ë‚˜ì˜¬ ê²ƒì´ë¼ê³  ì˜ˆìƒí–ˆì§€ë§Œ boolean
type R2 = Equal<never, never>; // trueê°€ ë‚˜ì˜¬ ê²ƒì´ë¼ê³  ì˜ˆìƒí–ˆì§€ë§Œ never
```

ìœ„ì˜ ì˜ˆì œì—ì„œëŠ” ë¶„ë°°ë²•ì¹™ì— ì˜í•´ ì˜ˆìƒì¹˜ëª»í•œ íƒ€ì…ìœ¼ë¡œ ì¶”ë¡ ëœë‹¤. ë¶„ë°°ë²•ì¹™ì„ ë§‰ê³  ì‹¶ë‹¤ë©´..

```ts
type Equal<A, B> = [A] extends [B] ? ([B] extends [A] ? true : false) : false;
```

í•˜ì§€ë§Œ ì´ ì˜ˆì œëŠ” anyì™€ ë‹¤ë¥¸ íƒ€ì…ì„ êµ¬ë³„í•˜ì§€ ëª»í•œë‹¤.anyì™€ ë‹¤ë¥¸ íƒ€ì…ì„ êµ¬ë³„í•˜ê³  ì‹¶ë‹¤ë©´..

```ts
type Equal2<X, Y> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y
  ? 1
  : 2
  ? true
  : false;
```

ğŸ’¡ ë™ì‘ê³¼ì •

`<T>() => T extends X ? 1 : 2` -> ì œë„¤ë¦­ í•¨ìˆ˜ë¥¼ ë§Œë“¤ì–´ Tê°€ Xì— í• ë‹¹ë  ìˆ˜ ìˆìœ¼ë©´ 1, ì•„ë‹ˆë©´ 2ë¥¼ ë°˜í™˜í•œë‹¤.<br>
`extends (<T>() => T extends Y ? 1 : 2) ? true : false` -> Xì™€ Yê°€ ê°™ë‹¤ë©´ ë‘ í•¨ìˆ˜ëŠ” ë™ì¼í•œ íƒ€ì…ì´ ë˜ì–´ true ë°˜í™˜í•˜ê³  ë‹¤ë¥´ë©´ falseë¥¼ ë°˜í™˜í•œë‹¤.

ğŸ’¡ ì˜ˆì œ

```ts
type A = EqualStrict<"hello", "hello">; // true (ê°™ì€ íƒ€ì…)
type B = EqualStrict<"hello", string>; // false ("hello"ëŠ” stringì˜ ë¶€ë¶„ì§‘í•©)
type C = EqualStrict<number, string>; // false (ì™„ì „íˆ ë‹¤ë¥¸ íƒ€ì…)
```

í•˜ì§€ë§Œ ìœ ì˜í•  ì ì´ ìˆë‹¤.

1. anyëŠ” ë‹¤ë¥¸ íƒ€ì…ê³¼ ì˜ êµ¬ë³„í•˜ì§€ë§Œ ì¸í„°ì„¹ì…˜ì„ ì¸ì‹í•˜ì§€ ëª»í•œë‹¤.
2. Equal2<any,known>ì˜ ê²½ìš°ëŠ” extendsë¥¼ falseë¡œ ë§Œë“œëŠ” Tê°€ ì—†ìŒì—ë„ falseê°€ ëœë‹¤.

5ï¸âƒ£ NotEqual
í•´ë‹¹ íƒ€ì…ì´ ì•„ë‹Œì§€ íŒë‹¨í•˜ëŠ” íƒ€ì…ì´ë‹¤.

```ts
type NotEqual<X, Y> = Equal<X, Y> extends true ? false : true;
```
