# 2.25 정교한 문자열 조작을 위해 템플릿 리터럴 타입을 사용하자

자바스크립트의 템플릿 리터럴 : ``(백틱), ${}(보간)

`이름은 ${name}입니다.`

타입스크립트의 템플릿 리터럴

- 템플릿 타입을 사용하면 정해진 문자열만 변수에 대입할 수 있다.
- “template “ + “This is literal” 이외의 값을 강제적으로 제한하는 것이다.

```ts
type Literal = "This is literal";
type Template = `template ${Literal}`;
const correct: Template = `template This is literal`; //⭕️
const wrong: Template = "template Something else"; // ❌ 오류 발생

console.log(correct); // -> template This is literal
```

## 타입을 넓혀 사용할 수 있다.

`type Template`은 "This is literal “ 뒤에 어떤 문자열이든 올 수 있는 문자열 타입

```ts
type Template = `This is literal ${string}`;
let str: Template = `This is literal `; // ⭕️
str = "This is literal hello"; // ⭕️
str = "This is literal 123"; // ⭕️
str = "This is literal"; // ❌
```

```ts
type City = "seoul" | "suwon" | "busan";
type Vehicle = "car" | "bike" | "walk";
type ID = `${City}까지 ${Vehicle}를 이용해서 갈 것입니다`;
const id: ID = "seoul까지 bike를 이용해서 갈 것입니다"; // ⭕️
```

City에는 seoul, suwon, busan이 올 수 있고 vehicle에는 car, bike, walk가 올 수 있다.

## 제네릭 및 infer를 함께 사용하면 더 강력하다.

xxtestxx에서 x 지우기

```ts
type RemoveX<Str> = Str extends `x${infer Rest}`
  ? RemoveX<Rest>
  : Str extends `${infer Rest}x`
  ? RemoveX<Rest>
  : Str;
type Removed = RemoveX<"xxtestxx">;
```

> 📝 infer
>
> `infer 변수명`으로 조건부 타입에서 특정 부분을 추출할 때 사용한다.
>
> ```ts
> type RemoveX<Str> = Str extends `x${infer Rest}` ? Rest : never;
> type Result = RemoveX<"xxtestxx">;
> ```
>
> 1️⃣ `x${infer Rest}`는 xxtestxx에서 첫번째 자리가 x면 나머지 xtestxx를 반환한다.<br>
> 2️⃣ 고로, Rest = 'xtestxx'가 되므로 최종적으로 RemoveX<'xxtestxx'>는 'xtestxx'가 된다.

동작과정

```ts
type RemoveX<Str> = Str extends `x${infer Rest}`
  ? RemoveX<Rest>
  : Str extends `${infer Rest}x`
  ? RemoveX<Rest>
  : Str;
type Removed = RemoveX<"xxtestxx">;
```

1️⃣ Str extends `x${infer Rest}` ? RemoveX<Rest> -> 'xxtestxx' 앞에 'x'가 있으므로 Rest = 'xtestxx'가 되고, 다시 RemoveX<'xtestxx'>를 호출한다.

2️⃣ Str extends `x${infer Rest}` ? RemoveX<Rest> -> 'xtestxx' → 앞에 'x'가 있으므로 Rest = 'testxx'이고, 다시 RemoveX<'testxx'>를 호출한다.

3️⃣ Str extends `x${infer Rest}` ? RemoveX<Rest>에서 더이상 지울 x가 없으므로 Str extends `${infer Rest}x`로 넘어간다.
'testxx' → 뒤에 'x'가 있으므로 Rest = 'testx'이고, 다시 RemoveX<'testx'>를 호출한다.

4️⃣ 'testx' → 뒤에 'x'가 있으므로 Rest = 'test'이고, 다시 RemoveX<'test'>를 호출한5️다.

5️⃣ 'test' → 더 이상 'x'가 없으므로 test가 반환된다.

# 2.26 추가적인 타입 검사에는 satisfies 연산자를 사용한다.

```ts
const universe = {
    sun: 'star',
    sriius: 'star',
    earth: {type: "planet", parent: "sun"},
}

//인덱스 시그니처 사용 -> {type: string, parent: string} | string} 둘 다 만족하므로 {type: string, parent: string} | string}로 타입이 추론된다.
const universe: {[key in 'sun' | 'sirius' | 'earth']: {type: string, parent: string} | string} = {
    sun:'star',
    sriius:'star',
    earth: {type: 'planet', parent: 'sun'}
}

//satisfies 사용 -> satisfies에 적은 타입으로 다시 한번 검사한다.
const universe = {
    sun: 'star',
    sriius: 'star',
    earth: {type: "planet", parent: "sun"},
}
const universe = {
    sun: 'star',
    sriius: 'star',
    earth: {type: "planet", parent"sun"}, {
        satisfies {
            [key in 'sun' | 'sirius' | 'earth']: {type: string, parent: string} | string
        }
    }
}
```

# 2.27 타입스크립트는 건망증이 심하다.

```ts
try {
} catch (error) {
  if (error as Error) {
    error.message; // 'error' is of type 'unknown'
  }
}
```

❓ error타입을 Error로 강제했는데 왜 타입이 'unknown' 으로 뜰까? <br>
✅ 조건문의 참, 거짓을 판단할 때만 주장한 타입이 사용되기 때문에 조건문을 나오면 타입이 다시 unknown이 된다.

❓ 한번 주장한 타입을 계속 유지하고 싶다면?
✅ 1. 변수를 사용한다.

```ts
try {
} catch (error) {
  const err = error as Error;
  if (err) {
    error.message;
  }
}
```

✅ 2.instanceof를 사용한다.

```ts
try {
} catch (error) {
  if (error instanceof Error) {
    error.message;
  }
}
```

# 2.28 원시 자료형에도 브랜딩 기법을 사용할 수 있다.

브랜딩 기법을 사용하면 string, number 같이 원시 자료형 타입을 더 세밀하게 구분할 수 있다.

```ts
const kmToMile = (km: number) => {
  return km * 0.62;
};
const mile = kmToMile(3);
console.log(mile); // -> 1.8599999999999999
```

```ts
type Brand<T, B> = T & { _brand: B };
type KM = Brand<number, "km">;
type Mile = Brand<number, "mile">;

const kmToMile = (km: number) => {
  return (km * 0.62) as Mile;
};

const km = 3 as Mile;
const mile = kmToMile(km); // const mile의 타입은 Mile
const mile2 = 5 as Mile;
kmToMile(mile2); // ❌ kmToMile에는 KM 타입만 와야하므로 Mile타입은 넣을 수 없다.
```

`type Brand<T,B> = T & {_brand: B};` : T는 원래 자료형(T), B는 새로 만들 자료형({\_brand: B})<br>
`type KM = Brand<number,'km'>;` : T에는 number가 들어가고 B에는 km이 들어간다.

# 2.29 배운 것을 바탕으로 타입을 만들어보자

## 판단하는 타입 만들기

1️⃣ IsNever

never인지 판단하는 타입이다.

```ts
type IsNever<T> = [T] extends [never] ? true : false;
```

2️⃣ IsAny

any인지 판단하는 타입이다.

```ts
type IsAny<T> = string extends number & T ? true : false;
```

3️⃣ IsArray

배열인지 판단하는 타입이다.

```ts
type IsArray<T> = IsNever<T> extends true
  ? false
  : T extends readonly unknown[]
  ? IsAny<T> extends true
    ? false
    : true
  : false;
```

동작과정

1. `IsNever<T> extends true` → T가 never이면 false 반환
2. `T extends readonly unknown[]` → T가 배열이면 다음 조건 실행
3. `IsAny<T> extends true` → T가 any이면 false 리턴
4. 모든 조건을 통과하면 true (즉, T는 배열이다!)

4️⃣ IsTuple

배열 중 튜플만 판단하는 타입이다.

```ts
type IsTuple<T> = IsNever<T> extends true
  ? false
  : T extends readonly unknown[]
  ? number extends T["length"]
    ? false
    : true
  : false;
```

💡 동작과정

1. `IsNever<T> extends true ? false` -> IsNever<T>가 true인지 확인, T가 never이면 false 반환
2. `T extends readonly unknown[]`-> T가 배열인지 확인 (T extends readonly unknown[]),배열이 아니면 false 반환
3. `number extends T["length"] ? false : true : false` ->T["length"]가 number로 확장되는지 확인,배열의 length가 number이면 일반 배열이므로 false, 그렇지 않으면 튜플이므로 true 반환

5️⃣ IsUnion

유니언인지 판단하는 타입이다.

```ts
type IsUnion<T> = IsNever<T> extends true
  ? false
  : T extends T
  ? [U] extends [T]
    ? false
    : true
  : false;
```

💡 동작과정

1. `(IsNever<T> extends true ? false)` -> T가 never인지 확인한다.
2. `T extends T`-> 분배법칙을 활성화한다.
3. `[U] extends [T] ? false : true : false` -> T가 유니언이면 [U] extends [T]가 false가 되면 유니언임을 의미하고 유니언이 아니라면 true가 되면서 단일 타입임을 의미한다.

## 집합 관련 타입 만들기

1️⃣ Omit

특정 객체에서 지정한 속성을 제거하는 타입이다.<br>
내장 유틸리티 타입이다.

```ts
type Diff<A, B> = Omit<A & B, keyof B>;
type R = Diff<
  { name: string; age: number },
  { name: string; married: boolean }
>;

// R에 마우스오버하면 type R = {age: number}이 나온다.
```

💡 동작과정

`A & B` -> `name: string, age: number, married: boolean `<br>
`keyof B` -> `name: string, married: boolean`<br>
`Omit` -> `A & B`에서 `keyof B`를 제거 <br>
`R` - > `age: number`만 남는다.

2️⃣ Diff

두 개의 객체를 비교하여 하나에서 다른 하나의 속성을 제거하는 타입이다.<br>
Omit을 활용한 유틸리티 타입이다.

```ts
type SymDiff<A, B> = Omit<A & B, keyof (A | B)>;
type R = SymDiff<
  { name: string; age: number },
  { name: string; married: boolean }
>;

// R에 마우스오버하면 type R = {age: number, married: boolean}이 나온다.
```

💡 동작과정

`A & B` -> `{ name: string; age: number; married: boolean }`<br>
`keyof (A | B) `-> `"name" | "age" | "married"`<br>
`Omit<A & B, keyof (A | B)>` -> `{age: number, married: boolean}`만 남는다.

2️⃣-1️⃣ 유니언에서 대칭차집합 적용

```ts
type SymDiffUnion<A, B> = Exclude<A | B, A & B>;
type R = SymDiffUnion<1 | 2 | 3, 2 | 3 | 4>;

// R에 마우스오버하면 1|4가 나온다.
```

3️⃣ Exclude

어떤 타입(A | B)에서 다른 타입(A & B)을 제거하는 타입이다.

```ts
type IsSubset<A, B> = A extends B ? true : false;
type R1 = IsSubset<string, string | number>; // string은 string | number의 부분집합이므로 true
type R2 = IsSubset<{ name: string; age: number }>; //{ name: string; age: number }는 본인과 동일하므로 true
type R3 = IsSubset<symbol, unknown>; // 모든 타입은 unknown의 서브타입이므로 true
```

4️⃣ Equal

두 타입이 동일한지 판단하는 타입이다.

```ts
type Equal<A, B> = A extends B ? (B extends A ? true : false) : false;

type R1 = Equal<boolean, true | false>; // true가 나올 것이라고 예상했지만 boolean
type R2 = Equal<never, never>; // true가 나올 것이라고 예상했지만 never
```

위의 예제에서는 분배법칙에 의해 예상치못한 타입으로 추론된다. 분배법칙을 막고 싶다면..

```ts
type Equal<A, B> = [A] extends [B] ? ([B] extends [A] ? true : false) : false;
```

하지만 이 예제는 any와 다른 타입을 구별하지 못한다.any와 다른 타입을 구별하고 싶다면..

```ts
type Equal2<X, Y> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y
  ? 1
  : 2
  ? true
  : false;
```

💡 동작과정

`<T>() => T extends X ? 1 : 2` -> 제네릭 함수를 만들어 T가 X에 할당될 수 있으면 1, 아니면 2를 반환한다.<br>
`extends (<T>() => T extends Y ? 1 : 2) ? true : false` -> X와 Y가 같다면 두 함수는 동일한 타입이 되어 true 반환하고 다르면 false를 반환한다.

💡 예제

```ts
type A = EqualStrict<"hello", "hello">; // true (같은 타입)
type B = EqualStrict<"hello", string>; // false ("hello"는 string의 부분집합)
type C = EqualStrict<number, string>; // false (완전히 다른 타입)
```

하지만 유의할 점이 있다.

1. any는 다른 타입과 잘 구별하지만 인터섹션을 인식하지 못한다.
2. Equal2<any,known>의 경우는 extends를 false로 만드는 T가 없음에도 false가 된다.

5️⃣ NotEqual
해당 타입이 아닌지 판단하는 타입이다.

```ts
type NotEqual<X, Y> = Equal<X, Y> extends true ? false : true;
```
