# 3.10 Promise, Awaited íƒ€ì… ë¶„ì„í•˜ê¸°

```ts
(async () => {
  const str = await Promise.resolve('promise');
// const str: string
  const all = await Promise.all([
// const all: [string, number, boolean]
    'string',
    Promise.resolve(123),
    Promise.resolve(Promise.resolve(true)),
  ]);
  const chaining = await Promise.resolve('hi')
// const chaining: boolean | void
    .then(() => {
      return 123;
    })
    .then(() => {
      return true;
    })
    .catch((err) => {
      console.error(err);
    });
})();
```
1ï¸âƒ£ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì˜ Promise

PromiseëŠ” ê¸°ì¡´ì— ìë°”ìŠ¤í¬ë¦½íŠ¸ì— ìˆëŠ” ê°ì²´ì´ë¯€ë¡œ ë”°ë¡œ êµ¬í˜„í•  í•„ìš”ê°€ ì—†ë‹¤.<br>
PromiseConstructor ì¸í„°í˜ì´ìŠ¤ê°€ ì‹¤ì œ Promise ê°ì²´ì˜ íƒ€ì…
```ts
//lib.es2015.promise.d.ts

interface PromiseConstructor {
  readonly prototype: Promise<any>;
  new <T>(executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void): Promise<T>;
  all<T extends readonly unknown[] | []>(values: T): Promise<{ -readonly [P in keyof T]: Awaited<T[P]> }>;
  race<T extends readonly unknown[] | []>(values: T): Promise<Awaited<T[number]>>;
  reject<T = never>(reason?: any): Promise<T>;
  resolve(): Promise<void>;
  resolve<T>(value: T): Promise<Awaited<T>>;
  resolve<T>(value: T | PromiseLike<T>): Promise<Awaited<T>>;
}

declare var Promise: PromiseConstructor;
```

`declare var Promise: PromiseConstructor;` : ê¸°ì¡´ Promise ê°’ì— íƒ€ì…ë§Œ ë¶™ì´ê³ ì declareë¥¼ ì‚¬ìš©í•´ì„œ íƒ€ì…ì„ ì„ ì–¸
newë¥¼ ë¶™ì—¬ í˜¸ì¶œí•  ìˆ˜ë„ ìˆê³  all, race, reject, resolve ë“±ì˜ ë©”ì„œë“œê°€ ìˆë‹¤ê³  ì•Œë ¤ì£¼ê³  ìˆìŠµë‹ˆë‹¤.

```ts
const str1 = Promise.resolve('promise');
// const str1: Promise<string>
const str2 = await Promise.resolve('promise');
// const str2: string
export {};  // export {}ëŠ” top level awaitì—ì„œ ì—ëŸ¬ê°€ ë°œìƒí•˜ëŠ” ê²ƒì„ ë§‰ê¸° ìœ„í•´ ì¶”ê°€
```
- str1 -> resolveì˜ ë°˜í™˜ê°’ì´ Promise<Awaited<string>><br>
- str2 -> resolveì˜ ë°˜í™˜ê°’ì´ Awaited<Promise<Awaited<string>>><br>
â—ï¸ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì—ì„œ awaitì´ ë¶™ìœ¼ë©´ íƒ€ì…ì´ Awaited ì œë„¤ë¦­ íƒ€ì…ìœ¼ë¡œ ê°ì‹¸ì§„ë‹¤.

â“ Promise<Awaited<string>>ì€ ì™œ Promise<string>ì´ê³ , Awaited<Promise<Awaited<string>>>ì€ ì™œ stringì¼ê¹Œ?

âœ… Awaited<T>ì˜ ì •ì˜ë¥¼ ì‚´í´ë³´ë©´ ì•Œ ìˆ˜ìˆë‹¤.

```ts
type Awaited<T> = 
    T extends null | undefined ? T :
    T extends object & { then(onfulfilled: infer F): any }
        ? F extends (value: infer V, ...args: any) => any
            ? Awaited<V>
            : never
        : T;
```
> ### Awaited<ê°ì²´ê°€ ì•„ë‹Œ ê°’> === ê°ì²´ê°€ ì•„ë‹Œ ê°’
> **ì²« ë²ˆì§¸ ì»¨ë””ì…”ë„ íƒ€ì…** : Tê°€ nullì´ë‚˜ undefinedì¸ì§€ í™•ì¸í•œë‹¤.( Awaited<null>ì€ nullì´ê³ , Awaited<undefined>ëŠ” undefinedì´ë‹¤.)
>
> **ë‘ ë²ˆì¬ ì»¨ë””ì…”ë„ íƒ€ì…** : `Tê°€ object & { then(onfulfilled : infer F, ...args : infer _) : any`ë¥¼ extendsí•˜ëŠ”ì§€ í™•ì¸í•œë‹¤. 
>Tê°€ string, boolean, numberì˜ ê²½ìš°ëŠ” objectê°€ ì•„ë‹ˆë¯€ë¡œ falseê°€ ëœë‹¤. Awaited<string>ì€ string, Awaited<boolean>ì€ boolean, Awaited<number>ëŠ” numberì´ë‹¤. 
> 
>ğŸ’¡ ì´ì— ì˜í•´ str1ì˜ íƒ€ì…ì¸ Promise<Awaited<string>>ì€ Promise<string>ì´ ëœë‹¤. 

> ### â“Tê°€ ê°ì²´ë¼ë©´? Awaited<Promise<T>> === Awaited<T>
> 1. Tê°€ ê°ì²´ì¸ ê²½ìš°ì—ë„ ì¶”ê°€ë¡œ `{ then(onfulfilled: infer F, ...args: infer _) : any`ë¥¼ ë§Œì¡±í•´ì•¼ í•œë‹¤.
> 
> 2. ì´ë¥¼ ë§Œì¡±í•˜ê¸° ìœ„í•´ì„œëŠ” thenì´ë¼ëŠ” ë©”ì„œë“œë¥¼ ê°€ì§€ê³  ìˆì–´ì•¼ í•œë‹¤.(ëŒ€í‘œì ìœ¼ë¡œ Promise ì¸ìŠ¤í„´ìŠ¤ê°€ then ë©”ì„œë“œë¥¼ ê°–ê³  ìˆë‹¤.
> ```ts
> interface Promise<T> {
> then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
> catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
> } // âœ… thenì„ ê°€ì§€ê³  ìˆìŒ!
>```
> 3. Awaitedì—ì„œ Tê°€ Promiseì´ë©´ thenì˜ ì²« ë²ˆì§¸ ë§¤ê°œë³€ìˆ˜ì¸ Fë¥¼ inferí•©ë‹ˆë‹¤.
>
> ```ts
> type Result<T>
> Promise<T> extends { then(onfulfilled: infer F, ...args: infer _): any }
> ? true : false;
> // type Result<T> = true
>```
>ìœ„ ì½”ë“œì—ì„œ trueê°€ ë‚˜ì˜¤ëŠ” ê²ƒì„ ë³´ì•„ Promise ê°ì²´ê°€ object & { then(onfulfilled: infer F, ...args: infer _): anyë¥¼ extendsí•œë‹¤ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆë‹¤.( 1,2,3 ë§Œì¡±)
>
> 4. F ê°€ inferë˜ë©´ ë‹¤ì‹œ Fê°€ `((value: infer V, ...args: infer _) => any)`ë¥¼ extendsí•˜ëŠ”ì§€ í™•ì¸í•œë‹¤.
> 
> 5. extendsí•œë‹¤ë©´ ì²« ë²ˆì§¸ ë§¤ê°œë³€ìˆ˜ Vë¥¼ inferí•œë‹¤. 
>
> ```ts
> F extends ((value: infer V, ...args: infer _) => any) ? 
>       Awaited<V> :
>        never:
>```


â˜‘ï¸ ë‘ ë²ˆì˜ infer ê³¼ì • ì‹¤ì œ ì˜ˆì‹œ

```ts 
Promise.resolve('hi')
.then((data) => {
data;
})
// (parameter) data: string
``` 
1. Promise.resolve('hi')ëŠ” Promise<string> íƒ€ì…ì´ë‹¤.<br>
2. Promise ì¸ìŠ¤í„´ìŠ¤ì´ë¯€ë¡œ then ë©”ì„œë“œë¥¼ í˜¸ì¶œí•œë‹¤.
3. thenì˜ ì²« ë²ˆì§¸ ë§¤ê°œë³€ìˆ˜ íƒ€ì…ì¸ FëŠ” (data) => { data; }ì˜ íƒ€ì…ì´ë‹¤. 
4. ë‹¤ì‹œ Fì˜ ì²« ë²ˆì§¸ ë§¤ê°œë³€ìˆ˜ íƒ€ì…ì¸ VëŠ” dataì˜ íƒ€ì…ì´ë‹¤.


â˜‘ï¸ Promise ì¸ìŠ¤í„´ìŠ¤ì˜ íƒ€ì…
```ts
interface Promise<T> {
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
}
```
1. Promise<X> ì•ˆì˜ ê°’ì€ X
2. then((value: X) => ...)ì˜ ì½œë°±ì´ F
3. Fì˜ ì²« ë²ˆì§¸ ì¸ì value: Xë¥¼ infer Vë¡œ êº¼ëƒ„
4. ê·¸ë˜ì„œ V = X

2ï¸âƒ£ Promise.all

```ts
const all = await Promise.all([
  'string',
  Promise.resolve(123),
  Promise.resolve(Promise.resolve(true)),
]);
// const all: [string, number, boolean]
export {};
```

â˜‘ï¸ Promise.all íƒ€ì…
```ts
interface PromiseConstructor {
  ...
  all<T extends readonly unknown[] | []>(values: T): Promise<{ -readonly [P in keyof T]: Awaited<T[P]> }>;
  ...
}
```

- Promise.allì—ì„œì˜ valuesì˜ íƒ€ì…ì¸ TëŠ” ì˜ˆì œì—ì„œì˜ [string, Promise<number>, Promise<Promise<boolean>>]ì´ë‹¤.<br>
- Promise.allì˜ ë°˜í™˜ê°’ì€ Promise<{ -readonly [P in keyof T] : Awaited<T[P]> }>;ì¸ ë§¤í•‘ëœ ê°ì²´ íƒ€ì…ìœ¼ë¡œ, ì•ì„  ê·œì¹™ 1ê³¼ 2ì— ì˜í•´ [string, number, boolean]ê°€ ë‚˜ì˜¨ë‹¤.

3ï¸âƒ£ ì²´ì´ë‹í•œ Promiseì˜ íƒ€ì…
```ts
const chaining = await Promise.resolve('hi')
  .then(() => {
    return 123;
  })
  .then(() => {
    return true;
  })
  .catch((err) => {
    console.error(err);
  });
// const chaining: boolean | void
export {};
```
â˜‘ï¸ then, catch íƒ€ì…

```ts
interface Promise<T> {
  then<TResult1 = T, TResult2 = never>(
    onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, 
    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
  ): Promise<TResult1 | TResult2>;
  catch<TResult = never>(
    onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
  ): Promise<T | TResult>;
}
```
- TResult1: ì„±ê³µí–ˆì„ ë•Œ .then() ì½œë°±ì˜ ë°˜í™˜ê°’ íƒ€ì…
- TResult2: ì‹¤íŒ¨í–ˆì„ ë•Œ .then()ì˜ ì—ëŸ¬ ì½œë°± ë°˜í™˜ê°’ íƒ€ì…
- .then() ì „ì²´ëŠ” Promise<TResult1 | TResult2> ë¥¼ ë°˜í™˜í•œë‹¤.

ğŸ“ PromiseLike<T>ë€? <br>
ì§„ì§œ PromiseëŠ” ì•„ë‹ˆì§€ë§Œ, Promiseì²˜ëŸ¼ í–‰ë™í•  ìˆ˜ ìˆëŠ” ê°ì²´ì´ë‹¤. then() ë©”ì„œë“œë§Œ ìˆìœ¼ë©´ promiseë¡œ ê°„ì£¼ëœë‹¤.

**ì˜ˆì œ**
```ts
const chaining = await Promise.resolve('hi')
  .then(() => {
    return 123; // number
  })
  .then(() => {
    return true; // boolean
  })
  .catch((err) => {
    console.error(err); // void
  });
// const chaining: boolean | void
export {};
```

ğŸ’¡ ì¶”ë¡  ê³¼ì •
1. 123ì€ TResult1ì´ ëœë‹¤. ì¦‰, numberì´ë‹¤.
2. TResult2ëŠ” ì„¤ì •í•˜ì§€ ì•Šì•˜ìœ¼ë‹ˆ neverì´ ë˜ê³ 
3. Promise<number | never> â†’ Promise<number>
4. ìœ„ì™€ ê°™ì€ ë°©ë²•ìœ¼ë¡œ ë‘ ë²ˆì§¸ thenì€ trueì´ë¯€ë¡œ Promise<boolean>ì´ ëœë‹¤.(ì²«ë²ˆì§¸ Promise<number>ì€ Promise<boolean>ì— ì˜í•´ ë®ì–´ì”Œì›Œì§„ë‹¤.)
5. catch ì½œë°±ì´ ì•„ë¬´ê²ƒë„ returní•˜ì§€ ì•Šìœ¼ë¯€ë¡œ TResultì€ voidê°€ ëœë‹¤. 
6. ì „ì²´ íƒ€ì… Promise<T | TResult>ì€ Promise<boolean | void>ê°€ ëœë‹¤.
7. await í•˜ë©´ ìµœì¢…ì ìœ¼ë¡œ boolean | voidê°€ ë‚˜ì˜¨ë‹¤.

